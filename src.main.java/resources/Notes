Good links :--->
------------
http://fastlearning.in/examples/java.php	
https://www.guru99.com/java-stack-heap.html
http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/
http://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/
https://www.mkyong.com/tutorials/spring-boot-tutorials/


Topic:							                                 :: String ::

String is final and immutable class present in java.lang package, final means class can`t be inherited by any other class to override its functionality and Immutable means once object of the class is created then it can`t be modified if we modify it then String will return new modified object. 

Que: So How do you manipulate String in Java without creating String garbage? 
Ans: By using StringBuffer or StringBuilder.

Properties of String and StringBuffer :
---------------------------------------
1) String is immutable in Java:  String is by design immutable in Java .Immutability offers lot of benefit to the String class e.g. its hashcode value can be cached as HashMap key which makes it a faster and one of the reason why String is a popular key in HashMap, Because String is final it can be soafely shared between multiple threads without any extra synchronization.

2) When we represent string in double quotes like "abcd" they are referred as String literal and String literals are created in String pools. When you compare two same String literals using equality operator "==" it returns true because they are actually same instance of String. Anyway comparing object with equality operator is bad practice in Java and you should always use equals method to check equality.

3) "+" operator is overloaded for String and used to concatenate two strings. Internally "+" operation is implemented using either StringBuffer or StringBuilder.

5) String class overrides equals() and hashcode() method and two Strings are considered to be equal by equals() method if they contain exactly same character in same order and in same case. If you want to ignore case comparison of two strings then consider using equalsIgnoreCase() method. Another worth nothing point is that equals method must be consistent with compareTo() method for String because SortedSet and SortedMap e.g. TreeSet and TreeMap uses compareTo() method to compare String in Java.

7) toString() method provides String representation of any object and its declared in Object class and its recommended for other class to implement this and provide String representation.

9) In Java you can create String from char array, byte array, another string, from StringBuffer or from StringBuilder. Java String class provides constructor for all of these.


Problem with String :-->
----------------------
One of its biggest strength Immutability is also biggest problem if not used correctly. many times we create a String object and then perform a lot of operation on them e.g. converting string into uppercase, lowercase , getting substring out of it , concatenating with other string etc. Since String is an immutable class every time a new String is created and older one is discarded which creates lots of temporary garbage in heap. 
If String is created using String literal they remain in String pool. To resolve this problem Java provides us two Classes StringBuffer and StringBuilder. String Buffer is an older class but StringBuilder is relatively new and added in JDK 5.

Differences between String and StringBuffer :-->
----------------------------------------------
Main difference between String and StringBuffer is that String is immutable while StringBuffer is mutable means you can modify a StringBuffer object once you created. It will not create new object and will return same object with updated values. This mutable property makes StringBuffer an ideal choice for dealing with Strings in Java. You can convert a StringBuffer into String by its toString() method. 

Difference between StringBuilder and StringBuffer :-->
---------------------------------------------------
StringBuffer is very good with mutable String but it has one disadvantage all its public methods are synchronized which makes it thread-safe but same time slow.
In JDK 5 they provided similar class called StringBuilder which is a copy of StringBuffer but without synchronization.
We should try to use StringBuilder whenever possible, it performs better in most of cases than StringBuffer class. If you see StringBuilder vs StringBuffer you will find that they have exactly similar all API methods applicable to StringBuffer are also applicable to StringBuilder in Java. On the other hand String vs StringBuffer is completely different and their API is also completely different, same is true for StringBuilder vs String.

Summary :-->
------------
In summary here are list of difference between StringBuffer, String and StringBuilder in Java :

1) String is immutable while StringBuffer and StringBuilder is mutable object.
2) StringBuffer is synchronized while StringBuilder is not which makes StringBuilder faster than StringBuffer.
3) Concatenation operator "+" is internal implemented using either StringBuffer or StringBuilder.
4) Use String if you require immutability, use StringBuffer if you need mutable + thread-safety then use StringBuilder if you require mutable + without thread-safety.



subString() -->
------------
Que : How subString method works in Java - How subString works or sometime asked as how does subString creates memory leak ?
Ans : subString method is used to get parts of String in Java. Itís defined in java.lang.String class, and it's an overloaded method. One version of subString method takes just beginIndex, and returns part of String started from beginIndex till end, while other takes two parameters,beginIndex and endIndex, and returns part of String starting from beginIndex to endIndex-1. Every time you call substring() method in Java,it will return a new String because of immutability.

Que : What will happen if beginIndex is equal to length in substring(int beginIndex) ?
Ans : No it won't throw IndexOutOfBoundException instead it will return empty String. Same is the case when beginIndex and endIndex is equal in case of second method. It will only throw StringIndexOutOfBoundsException when beginIndex is negative, larger than endIndex or larger than length of String.

Que : Do you know how substring works in Java? 
Ans : Most of Java developers fail here, because they don't know how exactly substring method works, until they have not seen the code of java.lang.String. If you look substring 
	  method inside String class, you will figure out that it calls String (int offset, int count, char value []) constructor to create new String object. What is interesting here is,value[], which is the same character array used to represent original string. So what's wrong with this? Answer is Memory leak. 
	  

Que : Why String is immutable or final ?
Ans : Though there could be many possible answer for this question and only designer of String class can answer this , I think below two does make sense :

1) Imagine StringPool facility without making string immutable , its not possible at all because in case of string pool one string object/literal e.g. "Test" has referenced by many reference variables, so if any one of them change the value others will be automatically gets affected i.e. lets say

		String A = "Test"
		String B = "Test"

		Now String B called "Test".toUpperCase() which change the same object into "TEST" , so A will also be "TEST" which is not desirable.

2) String has been widely used as parameter for many Java classes e.g. for opening network connection, you can pass hostname and port number as string , you can pass database URL as string for opening database connection, you can open any file in Java by passing name of file as argument to File I/O classes.
	   In case, if String is not immutable, this would lead serious security threat , I mean some one can access to any file for which he has authorization, and then can change the file name either deliberately or accidentally and gain access of those file. Because of immutability, you don't need to worry about those kind of threats. This reason also get with, Why String is final in Java, by making java.lang.String final, Java designer ensured that no one overrides any behavior of String class.

3) Since String is immutable it can safely shared between many threads ,which is very important for multi-threaded programming and to avoid any synchronization issues, Immutability also makes String instance thread-safe in Java, means you don't need to synchronize String operation externally.

4) Another reason of Why String is immutable in Java is to allow String to cache its hashcode , being immutable String in Java caches its hashcode, and do not calculate every time we call hashcode method of String, which makes it very fast as key to be used in hashmap in Java.In short because String is immutable, none can change its contents once created which guarantees hashCode of String to be same on multiple invocation.


Programms on String :-->
----------------------
1. Reverse String :--> 
A) com./test.analytical.ReverseWordsOfString
B) com./test.analytical.StringReverseExample
C) com./test.string.RevirseStringWithoutAPI

# Reverse Number :--> 
A) com./test.analytical.ReverseNumberExample

# Reverse Array :--> 
A) com./test.analytical.ReverseArray

# Duplicate characters in Sentence:-->
A) com./test.string.DuplicateCharsInString
B) com./test.analytical.SearchDuplicatesInJavaArray

# Search Word and index of word in Sentence:-->
A) com./test.string.SearchWordInTheText


----------------------------------------------------------------------------------------------------------------------

Topic						                            ::Collections::


List : -->
------------
List is an collection and can contain duplicate elements. You can access any element from itís index. List is more like array with dynamic length. ArrayList and LinkedList are implementation classes of List interface. Default size is 10.

Default size : ArrayList - 10  and   Vector - 10, 

public class ConcurrentListExample {
 
    public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        list.add("1");   list.add("2");    list.add("3");      list.add("4");      list.add("5");
         
        // get the iterator
        Iterator<String> it = list.iterator();
         
        //manipulate list while iterating
        while(it.hasNext()){
            System.out.println("list is:"+list);
            String str = it.next();
            System.out.println(str);
            if(str.equals("2"))list.remove("5");
            if(str.equals("3"))list.add("3 found");
            //below code don't throw ConcurrentModificationException
            //because it doesn't change modCount variable of list
            if(str.equals("4")) list.set(1, "4");
        }
    }
 
}

When we run above program, we get java.util.ConcurrentModificationException as soon as the ArrayList is modified. It happens because ArrayList iterator is fail-fast by design. What it means is that once the iterator is created, if the ArrayList is modified, it throws ConcurrentModificationException while iterating the list. 

If you check the console log, you will notice that exception is thrown by Iterator next() method. If you will look into the ArrayList source code, following method is called every time we invoke next() on iterator that throws exception.

final void checkForComodification() {
    if (modCount != expectedModCount)
        throw new ConcurrentModificationException();
}

Here modCount is the ArrayList variable that holds the modification count and every time we use add, remove or trimToSize method, it increments/decrements. expectedModCount is the iterator variable that is initialized when we create iterator with same value as modCount. This explains why we donít get exception if we use set method to replace any existing element.
So basically iterator throws ConcurrentModificationException if list size is changed.

Sometimes we want to add or remove elements from the list if we find some specific element, in that case we should use Concurrent Collection class ñ CopyOnWriteArrayList. This is a thread-safe variant of java.util.ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.


Difference between ArrayList vs LinkedList in Java :--->
---------------------------------------------------
Main difference between ArrayList and LinkedList is that ArrayList is implemented using resizeable array while LinkedList is implemented using doubly LinkedList.
ArrayList is more popular among Java programmer than LinkedList as there are few scenarios on which LinkedList is a suitable collection than ArrayList.

1) Since Array is an index based data-structure searching or getting element from Array with index is pretty fast. Array provides O(1) performance for get(index) method but remove is costly in ArrayList as you need to rearrange all elements. 
   On the Other hand LinkedList doesn't provide Random or index based access and you need to iterate over linked list to retrieve any element which is of order O(n).

2) Insertions are easy and fast in LinkedList as compared to ArrayList because there is no risk of resizing array and copying content to new array if array gets full which makes adding into ArrayList of O(n) in worst case, while adding is O(1) operation in LinkedList in Java.
   ArrayList also needs to update its index if you insert something anywhere except at the end of array.

3) Removal is like insertions better in LinkedList than ArrayList.

4) LinkedList takes more memory overhead than ArrayList because in ArrayList each index only holds actual object (data) but in case of LinkedList each node holds both data and address of next and previous node.

When to use LinkedList and ArrayList in Java --->
As I will say LinkedList is not as popular as ArrayList but still there are situation where a LinkedList is better choice than ArrayList in Java. 

Use LinkedList in Java if:
1) Your application can live without Random access because if you need nth element in LinkedList you need to first traverse up to nth element O(n) and than you get data from that node.

2) Your application has more insert or remove more than retrieval. Since insertion or removal doesn't involve resizing its much faster than ArrayList.

3) moving (copying) elements is costly if Array gets full and element needs to be added but traversing linkedList is faster to add an element.

Use ArrayList in Java for all there situation where you need a non-synchronized index based access.ArrayList is fast and easy to use, just try to minimize array resizing by constructing arrayList with proper initial size.


Difference between ArrayList and Vector In java :-->
--------------------------------------------
ArrayList and Vector both use Array as a data structure internally. However there are few differences in the way they store and process the data.

1) ArrayList is not synchronized but Vector is synchronized.
2) By default ArrayList size is 10. ArrayList increments by 50% of current array size if number of element exceeds from its capacity. While Vector increments by 100% means doubles the array size if total number of element exceeds than its capacity.
3) ArrayList is fast because it is non-synchronized. Vector is synchronized i.e. in multi-threaded environment, it will hold the other threads in runnable or non-runnable state until current thread releases the lock of object.
4) ArrayList uses Iterator interface to traverse the elements.Vector uses Enumeration interface to traverse the elements. But it can use iterator also.				
5) ArrayList does not define the increment size . Vector defines the increment size .
	You can find the following method in Vector Class

	public synchronized void setSize(int i) { //some code  }

Lets say you have stored 3 objects in Vector then size will be 3 of it but if you call v.setSize(10); then size become 10. now in 7 places it contains null object.
6) ArrayList is not a legacy class, it is introduced in JDK 1.2. Vector is a legacy class.



                                          Sort ArrayList in Ascending and Descending order
                                       ------------------------------------------------------   
Sorting ArrayList in Java with natural Order:--->
--------------------------------------------
Object stored in ArrayList must implement Comparable interface in Java and should override compareTo() method as per there natural order. In our example of natural order sorting in ArrayList we have implemented compareTo() of Comparable and sorted them based on brands. So an Apple smartphone comes before Nokia smartphone. Once your object is OK just store them in Java arraylist and pass that list to Collections.sort() method, this will sort the list in natural order of objects.

Sorting Java ArrayList with custom Order: --->
-----------------------------------------
To Sort a Java arrayList on Custom order we need to supply(pass) an external Comparator along-with Arraylist to Collections.sort(List, Comparator) method. 
Compare() method will define how sorting of objects will take place in ArrayList.In our example of custom order sorting of Java ArrayList we have created a PriceComparator which sorts objects based on there price. So you can get cheapest or expensive smartphone stored in ArrayList. 

Here is complete code example of sorting an arraylist in java on both natural and custom order by using Custom comparator.

package test;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class ArrayListSortingExample {

   private static class SmartPhone implements Comparable {
        private String brand;
        private String model;
        private int price;

        public SmartPhone(String brand, String model, int price){
            this.brand = brand;
            this.model = model;
            this.price = price;
        }
      
        @Override
        public int compareTo(SmartPhone sp) {
            return this.brand.compareTo(sp.brand);
        }

        @Override
        public String toString() {
            return "SmartPhone{" + "brand=" + brand + ", model=" + model + ", price=" + price + '}';
        }
      
    }
  
    private static class PriceComparator implements Comparator{

        @Override
        public int compare(SmartPhone sp1, SmartPhone sp2) {
            return (sp1.price < sp2.price ) ? -1: (sp1.price > sp2.price) ? 1:0 ;
        }
      
    }

    public static void main(String... args) {
      
        //creating objects for arraylist sorting example
        SmartPhone apple = new SmartPhone("Apple", "IPhone4S",1000);
        SmartPhone nokia = new SmartPhone("Nokia", "Lumia 800",600);
        SmartPhone samsung = new SmartPhone("Samsung", "Galaxy Ace",800);
        SmartPhone lg = new SmartPhone("LG", "Optimus",500);
      
        //creating Arraylist for sorting example
        ArrayList smartPhones = new ArrayList();
      
        //storing objects into ArrayList for sorting
        smartPhones.add(apple);
        smartPhones.add(nokia);
        smartPhones.add(samsung);
        smartPhones.add(lg);
      
        //Sorting Arraylist in Java on natural order of object
        Collections.sort(smartPhones);
      
        //print sorted arraylist on natural order
        System.out.println(smartPhones);
      
        //Sorting Arraylist in Java on custom order defined by Comparator
        Collections.sort(smartPhones,new PriceComparator());
      
        //print sorted arraylist on custom order
        System.out.println(smartPhones);
    
    }
}

Output:
[SmartPhone{brand=Apple, model=IPhone4S, price=1000}, SmartPhone{brand=LG, model=Optimus, price=500}, SmartPhone{brand=Nokia, model=Lumia 800, price=600}, SmartPhone{brand=Samsung, model=Galaxy Ace, price=800}]

[SmartPhone{brand=LG, model=Optimus, price=500}, SmartPhone{brand=Nokia, model=Lumia 800, price=600}, SmartPhone{brand=Samsung, model=Galaxy Ace, price=800}, SmartPhone{brand=Apple, model=IPhone4S, price=1000}]


When to use Comparator and Comparable :-->
------------------------------------
1) If there is a default way of sorting Object already decided during development of Class than use Comparable. This is intuitive and you given the class name people should be able to guess it correctly like Strings are sorted chronically,
Employee can be sorted by their Id etc. 
On the other hand if an Object should be sorted on multiple ways and client is specifying on which parameter sorting should take place than use Comparator interface.

for example Employee can again be sorted on name, salary or department and clients needs an API to do that. Comparator implementation can sort out this problem.

2) Some time you write code to sort object of a class for which you are not the original author, or you don't have access to code. In these cases you can not implement Comparable and Comparator is only way to sort those objects.

3) If you see then logical difference between these two is Comparator compares two objects provided to it, while Comparable interface compares "this" reference with the object specified..

4) Order of comparison is very important while implementing Comparable or Comparator interface. for example if you are sorting object based upon name than you can compare first name or last name on any order, so decide it judiciously.

5) Comparator has a distinct advantage of being self descriptive for example if you are writing Comparator to compare two Employees based upon their salary than name that comparator as SalaryComparator, on the other hand compareTo()


Example : Testing.java

--------------------

How to sort ArrayList in Descending Order in Java -->
ArrayList can also be sorted in descending or reverse order by using Collections.reverseOrder() and Collection.reverseOrder(Comparator cmp). Former method will sort in reverse order of natural ordering while later method will sort in the reverse order of specified comparator as shown in following example of sorting arrayList into reverse order :

//sorting ArrayList in descending or reverse order in Java
List unsortedList = Arrays.asList("abc", "bcd", "ade", "cde");
Collections.sort(unsortedList, Collections.reverseOrder());

System.out.println("Arraylist in descending order: " + unsortedList);


Output:
ArrayList before sorting in reverse order: [abc, bcd, ade, cde]
Arraylist in descending order: [cde, bcd, ade, abc]

How to sort ArrayList of String  in Case insensitive Order

ArrayList  of String can also be sorted with case insensitive comparison. String class defines a convenient case insensitive comparator which can be accessed
directly like String.CASE_INSENSITIVE_ORDER. If you pass this comparator to ArrayList.sort() which contains String then those will be sorted accordingly. Here is an
example of sorting arraylist in case insensitive order:

//sorting ArrayList on case insensitive order of String
unsortedList = Arrays.asList("abc", "bcd", "ABC", "BCD");
System.out.println("ArrayList before case insensitive sort: " + unsortedList);
             
Collections.sort(unsortedList, String.CASE_INSENSITIVE_ORDER);
System.out.println("ArrayList after case insensitive sort: " + unsortedList);

Output:
ArrayList before case insensitive sort: [abc, bcd, ABC, BCD]
ArrayList after case insensitive sort: [abc, ABC, bcd, BCD]



--------------------------------------------------------------------

Set : -->
--------
Set is a collection that cannot contain duplicate elements. Set interface doesnít allow random-access to an element in the Collection and we can use iterator or for-each loop to traverse the elements of a Set. The Java platform contains three general-purpose Set implementations: HashSet, TreeSet, and LinkedHashSet. 								

Default size: HashSet - 16

HashSet :-->
-----------
All the methods which are in Collection Interface are also in Set Interface by default but the main thing is that objects which are going to be stored in HashSet must override equals() and hashCode() method so that we can check for equality and no duplicate value are stored in our set.if we have created our own objects we need to implement hashCode() and equal() in such a manner that will be able to compare objects correctly when storing in a set so that duplicate objects are not stored,if we have not override this method objects will take default implementation of this method.

public boolean add(Object o)  Method is used to add element in a set which returns false if itís a duplicate value in case of HashSet otherwise returns true if added successfully.

Main feature of : -->
---------------
TreeSet stores in sorted order and is implemented using TreeMap. 
LinkedHashSet stores based on insertion order 
HashSet is just general purpose collection for storing object. HashSet is implemented using HashMap in Java.

TreeSet:--->
TreeSet is a SortedSet implementation which allows it to keep elements in the sorted order defined by either Comparable or Comparator interface. Comparable is used for natural order sorting and Comparator for custom order sorting of objects which can be provided while creating instance of TreeSet. 

let's see some similarities between them:--->

1) Duplicates : All three sets implements Set interface means they are not allowed to store duplicates.

2) Thread safety : HashSet, TreeSet and LinkedHashSet are not thread-safe, if you use them in multi-threading environment where one Thread modifies Set you need to externally synchronize them by using Collections.synchronizeSet()

3) Fail-Fast Iterator : Iterator returned by TreeSet, LinkedHashSet and HashSet are fail-fast Iterator. i.e. If Iterator is modified after its creation by any way other than Iterators remove() method, it will throw ConcurrentModificationException with best of effort.

Difference between HashSet, LinkedHashSet and TreeSet in Java :--->

Performance and Speed : HashSet is fastest, LinkedHashSet is second on performance or almost similar to HashSet but TreeSet 
----------------------  is bit slower because of sorting operation that it needs to perform on each insertion. TreeSet provides guaranteed O(log(n)) time for common operations like add, remove and contains,while HashSet and LinkedHashSet offer constant time performance e.g. O(1) for add, contains and remove given hash function uniformly distribute elements in bucket.

Ordering : HashSet does not maintain any order while LinkedHashSet maintains insertion order of elements much like LinkedList
---------- and TreeSet maintains sorting order of elements defined by either Comparable or Comparator interface.

Internal Implementation : HashSet is backed by an HashMap instance, LinkedHashSet is implemented using HashSet and LinkedList
------------------------  while TreeSet is backed up by TreeMap.

null : Both HashSet and LinkedHashSet allows null but TreeSet doesn't allow null and throw java.lang.NullPointerException when you insert null into TreeSet.
------
Since TreeSet uses compareTo() method of respective elements to compare them which throws NullPointerException while comparing with null, here is an Example: TreeSetLab.java

Comparison : HashSet and LinkedHashSet uses equals() method in Java for comparison but TreeSet uses compareTo() method for maintaining ordering.
------------  That's why compareTo() should be consistent to equals in Java. failing to do so break general contact of Set interface i.e. it can permit duplicates.

TreeSet vs HashSet vs LinkedHashSet - Example:----> SetComparision.java
---------------------------------------------
In this example we are demonstrating difference in ordering and time taking while inserting 1M records among TreeSet, HashSet and LinkedHashSet in Java. This will help to solidify some points which discussed in earlier section and help to decide when to use HashSet, LinkedHashSet or TreeSet in Java.

import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.TreeSet;

/**
 * Java program to demonstrate difference between TreeSet, HashSet and LinkedHashSet
 * in Java Collection.
 * @author
 */
public class SetComparision {
 
    public static void main(String args[]){            
        HashSet<String> fruitsStore = new HashSet<String>();
        LinkedHashSet<String> fruitMarket = new LinkedHashSet<String>();
        TreeSet<String> fruitBuzz = new TreeSet<String>();
     
        for(String fruit: Arrays.asList("mango", "apple", "banana")){
            fruitsStore.add(fruit);
            fruitMarket.add(fruit);
            fruitBuzz.add(fruit);
        }
       
        //no ordering in HashSet ñ elements stored in random order
        System.out.println("Ordering in HashSet :" + fruitsStore);

        //insertion order or elements ñ LinkedHashSet storeds elements as insertion
        System.err.println("Order of element in LinkedHashSet :" + fruitMarket);

        //should be sorted order ñ TreeSet stores element in sorted order
        System.out.println("Order of objects in TreeSet :" + fruitBuzz); 
     

        //Performance test to insert 10M elements in HashSet, LinkedHashSet and TreeSet
        Set<Integer> numbers = new HashSet<Integer>();
        long startTime = System.nanoTime();
        for(int i =0; i<10000000; i++){
            numbers.add(i);
        }

        long endTime = System.nanoTime();
        System.out.println("Total time to insert 10M elements in HashSet in sec : "
                            + (endTime - startTime));
     
     
        // LinkedHashSet performance Test ñ inserting 10M objects
        numbers = new LinkedHashSet<Integer>();
        startTime = System.nanoTime();
        for(int i =0; i<10000000; i++){
            numbers.add(i);
        }
        endTime = System.nanoTime();
        System.out.println("Total time to insert 10M elements in LinkedHashSet in sec : "
                            + (endTime - startTime));
       
        // TreeSet performance Test ñ inserting 10M objects
        numbers = new TreeSet<Integer>();
        startTime = System.nanoTime();
        for(int i =0; i<10000000; i++){
            numbers.add(i);
        }
        endTime = System.nanoTime();
        System.out.println("Total time to insert 10M elements in TreeSet in sec : "
                            + (endTime - startTime));
    }
}

Output
Ordering in HashSet :[banana, apple, mango]
Order of element in LinkedHashSet :[mango, apple, banana]
Order of objects in TreeSet :[apple, banana, mango]
Total time to insert 10M elements in HashSet in sec : 3564570637
Total time to insert 10M elements in LinkedHashSet in sec : 3511277551
Total time to insert 10M elements in TreeSet in sec : 10968043705


[When to use HashSet, TreeSet and LinkedHashSet in Java
Since all three implements Set interface they can be used for common Set operations like not allowing duplicates but since HashSet, TreeSet and LinkedHashSet has
there special feature which makes them appropriate in certain scenario. Because of sorting order provided by TreeSet, use TreeSet when you need a collection where
elements are sorted without duplicates. HashSet are rather general purpose Set implementation, Use it as default Set implementation if you need a fast,non-duplicate free
collection. LinkedHashSet is extension of HashSet and its more suitable where you need to maintain insertion order of elements, similar to LinkedList without compromising
performance for costly TreeSet. Another use of LinkedHashSet is for creating copies of existing Set, Since LinkedHashSet preservers insertion order, it returns Set 
which contains same elements in same order like exact copy. In short,although all three are Set interface implementation they offer distinctive feature, HashSet is
a general purpose Set while LinkedHashSet provides insertion order guarantee and TreeSet is a SortedSet which stores elements in sorted order specified by Comparator
or Comparable in Java.]


How to copy object from one Set to other :
----------------------------------------
Here is code example of LinkedHashSet which demonstrate How LinkedHashSet can be used to copy objects from one Set to another without losing order. You will get
exact replica of source Set, in terms of contents and order.Here static method copy(Set source) is written using Generics, This kind of parameterized method
provides type-safety and help to avoid ClassCastException at runtime.

import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;

/**
 * Java program to copy object from one HashSet to another using LinkedHashSet.
 * LinkedHashSet preserves order of element while copying elements.
 *
 * @author Javin
 */
public class SetUtils{
   
    public static void main(String args[]) {
       
        HashSet<String> source = new HashSet<String>(Arrays.asList("Set, List, Map"));
        System.out.println("source : " + source);
        Set<String> copy = SetUtils.copy(source);
        System.out.println("copy of HashSet using LinkedHashSet: " + copy);
    }
   
    /*
     * Static utility method to copy Set in Java
     */
    public static <T> Set<T> copy(Set<T> source){
           return new LinkedHashSet<T>(source);
    }
}
Output:
source : [Set, List, Map]
copy of HashSet using LinkedHashSet: [Set, List, Map]

Always code for interface than implementation so that you can replace HashSet to LinkedHashSet or TreeSet when your requirement changes. 


Quest : What is the difference in list and set ?
Ans : 1. List can store duplicate but not Set.
	  2. List allows random access of value using key but Set does`t allow.
	  3. add() method of both return boolean. List always return true but set returns false if we add duplicate value and value will not be added.
	  4. List provides ListIterator that can be used to traverse a List in both the directions(forward and backward) However it can not be used to traverse a Set. We can use Iterator (It works with List too) to traverse a Set.	
	  5. List can store multiple null but Set can store max one null as not allowed duplicate.
	  6. Set uses equals() internally to compare the object which is being stored but List doesn`t use it as it stores duplicate.
	  
----------------------------------------------------------------------------------------------

Map :-->
------
A Map is an object that stores data in key-value form. The Java platform contains three general-purpose Map implementations: HashMap, TreeMap, and LinkedHashMap.
The basic operations of Map are put, get, containsKey, containsValue, size, and isEmpty.

Default size : HashTable - 11, HashMap - 16

HashMap Class:-->
---------------
HashMap is a basic implementation of Map Interface, which stores data in key - value form. keys must be unique and values can be duplicate. HashMap allows max
one null key but multiple null values.
HashMap is not synchronized, but collections class provide methods (Collections.synchoronizedMap()) to make them synchronized. This class makes no guarantees for
the order of the map.

TreeMap Class :-->
---------------- 
TreeMap implements SortedMap and extends AbstractMap. TreeMap stores the data in sorted order based on the key. If key is user defined object then comparable 
interface needs to be implemented by that key object.
It does not stores null key but can have multiple null values.

Here are few ways to create TreeMap in Java:

1. TreeMap in Java using natural ordering of keys

	TreeMap naturalOrderMap = new TreeMap();

2. TreeMap with custom sorting order. Objects stored in this TreeMap will be ordered according to given Comparator.

	TreeMap customSortingMap = new TreeMap(Comparator comparator)

3. TreeMap from existing SortedMap

TreeMap sameOrderMap = new TreeMap(SortedMap sm)


LinkedHashMap Class :-->
----------------------
This stores data based on insertion-order. That is, When iterating a LinkedHashMap, the elements will be returned in the same order in which they were inserted.
It may have one null key and multiple null values.

HashTable class :-->
-------------------
It is same as HashMap except it is synchronized and It does not store any null key or null value.

Default size : HashTable - 11

Difference between HashMap and HashTable :-->
----------------------------------------------
Both HashMap and HashTable implements Map interface but there are some significant difference between them Some of them is thread-safety, synchronization and
speed. here are those differences :

1.The HashMap class is roughly equivalent to HashTable, except that Map is non synchronized and permits nulls whereas HashTable doesn't allow nulls.

2. HashMap is non synchronized whereas HashTable is synchronized, which means HashTable is thread-safe and can be shared between multiple threads but HashMap can
not be shared between multiple threads without proper synchronization. Java 5 introduces ConcurrentHashMap which is an alternative of HashTable and provides 
better scalability than HashTable in Java.

3. Another significant difference between HashMap vs HashTable is that Iterator in the HashMap is a fail-fast iterator and throw ConcurrentModificationException
 if any other Thread modifies the map structurally by adding or removing any element except Iterator's own remove() method while the enumerator for the HashTable
 does not throw ConcurrentModificationException and it allows addition of new elements in HashTable while one thread is Iterating over it . But this is not a guaranteed behaviour and will be done by JVM on best effort. This is also an important difference between Enumeration and Iterator in Java.

4. One more notable difference between HashTable and HashMap is that because of thread-safety and synchronization HashTable is much slower than HashMap if used in Single threaded environment. So if you don't need synchronization and HashMap is only used by one thread, it out perform HashTable in Java.

Note on Some Important Terms : -->
1)Synchronized means only one Thread can modify a hash table at one point of time. Basically, it means that any thread before performing an update on a HashTable will have to acquire a lock on the object while others will wait for lock to be released.

2)Fail-safe is relevant from the context of iterators. If an Iterator or ListIterator has been created on a collection object and some other thread tries to modify the collection object "structurally", a concurrent modification exception will be thrown. It is possible for other threads though to invoke  "set" method since it doesn't modify the collection "structurally". However, if prior to calling "set", the collection was modified structurally, then "IllegalArgumentException" will be thrown.

3)Structurally modification means deleting or inserting element which could effectively change the structure of map.

HashMap can be synchronized by

Map m = Collections.synchronizeMap(hashMap);

In Summary there are significant differences between HashTable and HashMap in Java e.g. thread-safety and speed and based upon that only use HashTable if you absolutely need thread-safety, if you are running Java 5 consider using ConcurrentHashMap .


*** How HashMap works in Java ****
http://javahungry.blogspot.com/2013/08/hashing-how-hash-map-works-in-java-or.html
http://www.javamadesoeasy.com/2015/04/concurrenthashmap-in-java.html  --> See diagram

https://www.geeksforgeeks.org/internal-working-of-hashmap-java/


Questions start with simple statement 

"Have you used HashMap before" or "What is HashMap? Why do we use it ì ?
HashMap stores data in key/vale form and accept null while HashTable doesn't, HashMap is not synchronized, HashMap is fast and so on. 

"Do you Know how HashMap works in Java or "How does get () method of HashMap works in Java"
HashMap works on principle of hashing, [we have put(key, value) and get(key) method for storing and retrieving Objects from HashMap]. When we pass Key and Value object to put() method of HashMap, HashMap implementation calls hashCode method on Key object and applies returned hashCode into its own hash function to find a bucket location, where keys and values are stored in form of a nested class called Entry (Map.Entry) . So you have concluded that from the previous line that Both key and value is stored in the bucket as a form of  Entry object . [Refer below Line :4]

1.  Public  V get(Object key)
   {
2.     if (key ==null)
3.     //Some code
4.     int hash = hash(key.hashCode());
    
5.     // if key found in hash table then  return value
6.     //    else return null
   }

   
Step 4:   int hash = hash(key.hashCode());   
We might wonder why we are calculating the hashvalue again using hash(hashValue). Answer is ,It defends against poor quality hash functions.
Now step 4 final hashvalue is used to find the bucket location at which the Entry object is stored or to store the Entry object. Entry object stores in the bucket like this (hash,key,value,bucketindex) .  
   
* Hash map works on the principle of hashing  : 

Next question could be about collision detection and collision resolution in Java HashMap  e.g. 

"What will happen if two different objects have same hashcode?î
Now from here onwards real confusion starts,
[Some time candidate will say that since hashcode is equal, both objects are equal and HashMap will throw exception or will not store them again etc],
Then you might want to remind them about equals() and hashCode() contract that two unequal object in Java can have same hashcode. Since HashMap use LinkedList to store object, this entry (object of Map.Entry comprise key and value ) will be stored in LinkedList. Great this answer make sense though there are many collision resolution methods available this is simplest and HashMap in Java does follow this.

"How will you retrieve Value object if two Keys will have same hashcode?î
Interviewee will say we will call get() method and then HashMap uses Key Object's hashcode [Refer above Line :4] to find out bucket location and retrieves Value object but then you need to remind him that there are two Value objects are stored in same bucket , so they will say about traversal in LinkedList until we find the value object , then you ask how do you identify value object because you don't have value object to compare ,Until they know that HashMap stores both Key and Value in LinkedList node or as Map.Entry they won't be able to resolve this issue.

But those bunch of people will say that after finding bucket location , we will call keys.equals() method to identify correct node in LinkedList and return associated value object for that key in Java HashMap . Perfect this is the correct answer.

In many cases interviewee fails at this stage because they get confused between hashCode() and equals() or keys and values object in Java HashMap  which is pretty obvious because they are dealing with the hashcode() in all previous questions and equals() come in picture only in case of retrieving value object from HashMap in Java. Some good developer point out here that using immutable, final object with proper equals() and hashcode() implementation would act as perfect Java HashMap keys and improve performance of Java HashMap by reducing collision. Immutability also allows caching there hashcode of different keys which makes overall retrieval process very fast and suggest that String and various wrapper classes e.g. Integer very good keys in Java HashMap.

Now if you clear this entire Java HashMap interview,  You will be surprised by this very interesting question "What happens On HashMap in Java if the size of the HashMap exceeds a given threshold defined by load factor ?". Until you know how HashMap works exactly you won't be able to answer this question. If the size of the Map exceeds a given threshold defined by load-factor e.g. if load factor is 75. it will act to re-size the map once it filled 75%. Similar to other collection classes like ArrayList, Java HashMap re-size itself by creating a new bucket array of size twice of previous size of HashMap , and then start putting every old element into that new bucket array. This process is called rehashing because it also applies hash function to find new bucket location. 

If you manage to answer this question on HashMap in Java you will be greeted by "do you see any problem with resizing of HashMap  in Java" , you might not be able to pick the context and then he will try to give you hint about multiple thread accessing the Java HashMap and potentially looking for race condition on HashMap in Java. 

So the answer is Yes there is potential race condition exists while resizing HashMap in Java, if two thread at the same time found that now HashMap needs resizing and they both try to resizing. on the process of resizing of HashMap in Java , the element in bucket which is stored in linked list get reversed in order during their migration to new bucket because java HashMap doesn't append the new element at tail instead it append new element at head to avoid tail traversing. If race condition happens then you will end up with an infinite loop. Though this point you can potentially argue that what the hell makes you think to use HashMap in multi-threaded environment to interviewer :)


Quest : What is the time complexity of Hashmap get() and put() method ?
Ans :   The hashmap implementation provides constant time performance for (get and put) basic operations
i.e the complexity of get() and put() is O(1) , assuming the hash function disperses the elements properly among the buckets. 


Few more question on HashMap in Java which is contributed by readers of Java revisited blog  :

1) Why String, Integer and other wrapper classes are considered good keys ?
Ans: String, Integer and other wrapper classes are natural candidates of HashMap key, and String is most frequently used key as well because String is immutable and final,and overrides equals() and hashcode() method. Other wrapper class also shares similar property. Immutability is required, in order to prevent changes on fields used to calculate hashCode() because if key object returns different hashCode during insertion and retrieval than it won't be possible to get object from HashMap.
     Immutability is best as it offers other advantages as well like thread-safety, If you can keep your hashCode same by only making certain fields final,
then you go for that as well. Since equals() and hashCode() method is used during retrieval of value object from HashMap, its important that key object correctly override these methods and follow contact. If unequal object return different hashcode than chances of collision will be less which subsequently improve performance of HashMap.

2) Can we use any custom object as key in HashMap ?
This is an extension of previous questions. Of course you can use any Object as key in Java HashMap provided it follows equals and hashCode contract and its hashCode should not vary once the object is inserted into Map. If custom object is Immutable than this will be already taken care because you can not change it once created.

3) Can we use ConcurrentHashMap in place of HashTable ?
Since we know HashTable is synchronized but ConcurrentHashMap provides better concurrency by only locking portion of map determined by concurrency level. ConcurrentHashMap is certainly introduced as HashTable can be used in place of it but HashTable provide stronger thread-safety than ConcurrentHashMap. 
See my post difference between HashTable and ConcurrentHashMap for more details. ***
 

Personally, I like this question because of its depth and number of concept it touches indirectly, if you look at questions asked during interview this HashMap  questions has verified

    Concept of hashing
    Collision resolution in HashMap
    Use of equals () and hashCode () and there importance in HashMap?
    Benefit of immutable object?
    Race condition on HashMap  in Java
    Resizing of Java HashMap


Just to summarize here are the answers which does makes sense for above questions

How HashMap  works in Java
HashMap  works on principle of hashing, we have put() and get() method for storing and retrieving object form HashMap .When we pass an both key and value to put() method to store on HashMap , it uses key object hashcode() method to calculate hashcode and they by applying hashing on that hashcode it identifies bucket location for storing value object. 
While retrieving it uses key object equals method to find out correct key value pair and return value object associated with that key. 
HashMap uses linked list in case of collision and object will be stored in next node of linked list.
Also HashMap stores both key+value tuple in every node of linked list.


Difference between HashSet and HashMap:--->

               Hash Map            								Hash Set
		--------------------								-----------------	   
# HashMap is a implementation of Map interface					HashSet is an implementation of Set Interface.
# HashMap Stores data in form of  key/value pair				HashSet Store only objects.
# Put method is used to add element in map and return void		Add method is used to add element in Set and it returns boolean.
# In hash map hashcode value is calculated using key object		Here member object is used for calculating hashCode value which can be same for two objects so  
                                                                equals() method is used to check for equality if it returns false that means two objects are different.
HashMap is faster than hashset because unique key is used       HashSet is slower than Hashmap.
to access object      


How HashSet internally works :
-----------------------------
http://javaconceptoftheday.com/how-hashset-works-internally-in-java/
* Set is a collection that contains no duplicate elements. So, it can contain at most one null and does`t allow rendom access of elements so we can traverse either using Iterator or for-each loop. HashSet implements Set interface in java. It is not synchronized so not thread safe.

Lets see what is the result, if we add duplicate elements to set:
Example:
public class Exercise {
   public static void main(String[] args) throws IOException {

        HashSet hashSet = new HashSet();
        hashSet.add(20);
        hashSet.add("HashSet Tutorial");
        hashSet.add("JavaCodeGeeks");
        hashSet.add(20);
        hashSet.add("HashSet Tutorial");
        System.out.println("Set contains " + hashSet);
   }
}
Output ==> Set contains [20, Hash Tutorial, JavaCodeGeeks]

* Here is the question, what happened internally when the duplicate elements are passed to the HashSet? The add(e) method in HashSet returns false when the 
  element exists in the HashSet, otherwise it returns true.

* HashSet implementation internally in Java

public class HashSet extends AbstractSet
    implements Set, Cloneable, java.io.Serializable
{
    private transient HashMap<E,Object> map;
    private static final Object PRESENT = new Object();    // Dummy value to associate with an Object in the backing Map

    public HashSet() {
        map = new HashMap<>();
    }

    public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }
    
    /**
    * Some code
    */ 
}

So, Set achieves the uniqueness in its elements through HashMap, So, when an object of HashSet is created, it will create an object of HashMap. In HashMap, each key is unique. When an element is passed to Set in its add(Element e) method, it is added as a key in the HashMap. Now, a value needs to be associated to the key so, Java uses a Dummy value (new Object) which is called PRESENT in HashSet. as shown above in example.

* In HashMap, the put(Key k,Value V) method returns:

   1.  null, if the key is unique. The key will be added to the map.
   2.  old value of the key, if the key is duplicated.

* In HashSet add(e) method, the return value (true/false) based on null check with returned value of map.put(key,value) method of HashMap .
public boolean add(E e) {
return map.put(e, PRESENT)==null;
}

* If map.put(key,value) returns null, then condition map.put(e, PRESENT)==null will return true and element is added to the HashSet.
* If map.put(key,value) returns the old value of the key, then map.put(e, PRESENT)==null will return false and element wont be added to the HashSet.

* remove() method also works in the same way.
public boolean remove(Object o) {
    return map.remove(o)==PRESENT;
}

[If you know how HashMap works internally then you can explain working of HashSet provided. As you know HashSet uses same values for all keys.
It is really important to override equals() and hashCode() for any object you are going to store in HashSet. Because the object is used as key in map, must override those method. So, make the object Immutable or effective immutable if possible ].
--------------------------------------------------------------

How to Convert Map to List in Java Example :-->
------------------------------------------
Map and List are two common data-structures available in Java and in this article we will see how can we convert Map values or Map keys into List in Java. 
Key in hashMap is just an addon to find values, so you can just pick the values from Map and create a List out of it. Map in Java allows duplicate value which is fine with List which also allows duplicates but Map doesn't allow duplicate key.

Map to List Example in Java:---> MaptoListJava.java
Here are few examples of converting Map to List in Java. We will see first how to convert hashMap keys into ArrayList and than hashMap values into ArrayList in Java.

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;

/**
 *Converting HashMap into ArrayList in Java
 */
public class MaptoListJava {

    public static void main(String... args) {
        HashMap<String, String> personalLoanOffers = new HashMap<String, String>();
        // preparing hashmap with keys and values
        personalLoanOffers.put("personal loan by DBS", "Interest rate low");
        personalLoanOffers.put("personal loan by Standard Charted", "Interest rate low");
        personalLoanOffers.put("HSBC personal loan by DBS", "14%");
        personalLoanOffers.put("Bank of America Personal loan", "11%");
      
        System.out.println("Size of personalLoanOffers Map: " + personalLoanOffers.size());
      
        //Converting HashMap keys into ArrayList
        List<String> keyList = new ArrayList<String>(personalLoanOffers.keySet());
        System.out.println("Size of Key list from Map: " + keyList.size());
      
        //Converting HashMap Values into ArrayList
        List<String> valueList = new ArrayList<String>(personalLoanOffers.values());
        System.out.println("Size of Value list from Map: " + valueList.size());


      
        List<Entry> entryList = new ArrayList<Entry>(personalLoanOffers.entrySet());
        System.out.println("Size of Entry list from Map: " + entryList.size());

    }
}

Output:
Size of personalLoanOffers Map: 4
Size of Key list from Map: 4
Size of Value list from Map: 4
Size of Entry list from Map: 4


-----------------------------------------------------------------------------------------------------

Read only List, Map and Set : -->
 
you can use Collections.unModifiableList() method  to create read only List,Collections.unmodifiableSet() for creating read-only Set like read only HashSet 
and similarly creating a read only Map by using Collections.unModifiableMap() and Any modification in read only List will result 
in java.lang.UnSupportedOperationException. 

[This read-only List example is based on Java 5 generics but also applicable to other Java version like JDK 1.4 or JDK 1.3, just remove Generics code i.e.
angle bracket which is not supported prior to Java 5. 
One common mistake programmer makes is that assuming fixed size List and read only List as same. As shown
in our 3 example of converting Array to Array List , we can use Arrays.asList() method to create and initialized List at same line. List implementation returned
by this method is fixed size and it doesnít allow adding or removal of element but it is not read only because you can update objects by calling set(index)
method.]

Read only List, Set and Map Example - Java

List :: Collections.unModifiableList() :: add, remove and set operation is not permitted,
                                       :: only read from the List by using get method or by using Iterator of List is permitted
Set  :: Collections.unModifiableSet()  :: add or remove elements is not permitted,
Map  :: Collections.unModifiableMap()  :: can not put new entries or update existing entries.

package example;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
imp\ort java.util.Map;
import java.util.Set;


public class ReadOnlyListSetMap {
 
    public static void main(String args[]) {            
       
        // creating List in Java
        List<String> contents = new ArrayList<String>();
     
        // initializing List in Java
        contents.add("Example");
        contents.add("Tutorial");
        contents.add("Program");
     
     
        // Currently This List is not read only, you can add or remove elements from List
        contents.add("Tips"); //should not be allowed if List is read only.
     
        System.err.println("normal List in Java : " + contents);
     
        //creating readonly List from contents
        contents = Collections.unmodifiableList(contents);
     
        //java.lang.UnsupportedOperationException -- no modification in read only list
     
       //not allowed as it is read-only List in Java
       contents.add("Can I add object into read only List - No");

       
        contents.remove("Example"); //remove not allowed in read only list
     
        //java.lang.UnSupportedOperation - List update not allowed
        contents.set(0, "Can I override or set object in read-only Set - No");

     
        //Creating read only Set in Java
        //similar to read-only List you can also create a Set which is read only
        //i.e. addition , removal and modification operation is not permitted on list
     
     
        //Creating a Set based on contents of List      
        Set<String> readOnlySet = new HashSet<String>(contents);
     
        System.out.println("original Set in Java : " + readOnlySet);

        //Set is not yet read-only you can still add elements into Set
        readOnlySet.add("Override");

        System.out.println("Set before making read only : " + readOnlySet);
     
        //making Set readonly in Java - no add remove or set operation permitted
        readOnlySet = Collections.unmodifiableSet(readOnlySet);
     
        //trying to add element in read only Set - java.lang.UnSupportedOperationException
        readOnlySet.add("You can not add element in read Only Set");
     
        //trying to remove element from read only set
        readOnlySet.remove("Example"); //you can not remove elements from read only Set
     
     
     
        // Creating read only Map in Java
        // Similar to List and Set you can also create read only or unmodifiable Map in Java
        // add , remove and override is not allowed on read only Map in Java
     
        Map<String, String> contries = new HashMap<String, String>();      
        contries.put("India", "New Delhi");
     
        //Map is not read only yet, you can still add entries into
        contries.put("UK", "London");
     
        System.out.println("Map in Java before making read only: " + contries);
     
        //Making Map read only in Java
        Map readOnlyMap = Collections.unmodifiableMap(contries);
       
        //you can not put a new entry in read only Map in Java
        readOnlyMap.put("USA", "Washington"); //java.lang.UnSupportedOperation
       
        //you can not remove keys from read only Map in Java
        readOnlyMap.remove("UK"); //java.lang.UnSupportedOperation
     
    }
 
}


--------------------------------------------------------------------------

Top 10 Collection Interview Questions Answers:

Quest: What is difference between fail-fast and fail-safe Iterators?
Ans  : Fail-fast Iterators throws ConcurrentModificationException when one Thread is iterating over collection object and other thread structurally modify Collection either by 	
       adding or removing objects on underlying collection. They are called fail-fast because they try to immediately throw Exception when they encounter failure.
       On the other hand fail-safe Iterators works on copy of collection instead of original collection.

Quest : What is difference between Synchronized Collection and ConcurrentCollection?
Ans   : Java5 has added several new ConcurrentCollection classes e.g. ConcurrentHashMap, CopyOnWriteArrayList, BlockingQueue etc, Java also provided way to get Synchronized copy of collection e.g. ArrayList, HashMap by using Collections.synchronizedMap() Utility function. One Significant difference is that ConccurentCollections has better performance than synchronized Collection because they lock only a portion of Map to achieve concurrency and Synchronization.
	
Quest: What is difference between Iterator and Enumeration?
Ans : 1. Iterator duplicate functionality of Enumeration with one addition of remove() method and both provide navigation functionally on objects of Collection.
      2. Iterator is more safe than Enumeration and doesn't allow another thread to modify collection object during iteration except remove() method  
         and throws ConcurrentModificaitonException. See Iterator vs Enumeraiton in Java for more differences.

Quest : How do you Sort objects on collection?
Ans   : This Collection interview question serves two purpose it not only test an important programming concept Sorting but Also utility class like Collections
        which provide several methods for creating synchronized collection and sorting. Sorting is implemented using Comparable or Comparator and when you call
	    Collections.sort() it gets sorted based on natural order specified in CompareTo method while Collections.sort(Comparator) will sort objects based on 
	    compare() method of Comparator. See Sorting in Java using Comparator and Comparable for more details.


-----------------------------------------

3 example of converting array to ArrayList and ArrayList to array?
 
How to convert Array to ArrayList in Java
In first section of this Java tutorial we will see how to convert from Array to ArrayList while in second section we will see opposite of it i.e. from ArrayList to Array. Main difference between these two is that once declared you can not change the size of former while later is dynamic which re-sizes itself whenever its capacity crossed threshold specified by load factor. So you can say former is fixed-size and you later are re-sizable. java.util.Arrays class act as a bridge between array to arraylist and used to convert from array to arraylist or arraylist to array.
If you like to learn more about Array you may check How to detect if Array contains duplicate or not and How to sort Array elements in Java in ascending order.

1) Using Arrays.asList() method
Look at the below example, we have an array which contains different kind of asset class e.g. equity, gold and foreign exchange etc and we want to convert into an
arraylist. This is the simplest way of converting from array to arraylist.


String[] asset = {"equity", "stocks", "gold", "foreign exchange","fixed income", "futures", "options"};
List assetList = Arrays.asList(asset);  

Its worth to note following point while using Arrays.asList() method for array to arraylist conversion:

1) This method returns a List view of underlying array.
2) List returned by this method would be fixed size.
3) Most important point to note is when you change an element into this List corresponding element in original array will also be changed.
4) Another important point is since List is fixed size, you can not add element into it. If you try you will get exception.
5) This is the most efficient way of converting array to arrayList as per my knowledge because it doesn't copy the content of underlying array to create list.
6) From Java 5 or JDK 1.5 onwards this method supports generic so you can generate type safe ArrayList from array. to know more about Generic see my post How Generic works in Java

One of the most important point related to Arrays.asList() method is that it returns a fixed size List not a read only List, although you can not
add() or remove() elements on this List you can still change existing elements by using set method. If you are using this to create read only List than 
its wrong,  Use Collections.unmodifiableList method to create read only collection in Java.


2) Array to ArrayList by using Collections.addAll method ::

This example of converting an array to arraylist is not that efficient as the earlier method but its more flexible.

String[] asset = {"equity", "stocks", "gold", "foriegn exchange", "fixed income", "futures", "options"}; 
List assetList = new ArrayList();

Collections.addAll(assetList, asset);

 Important point about this method of array to ArrayList conversion is :
1) Its not as fast as Arrays.asList() but more flexible.
2) This method actually copies the content of the underlying array into ArrayList provided.
3) Since you are creating copy of original array, you can add,modify and remove any element without affecting original one.
4) If you want to provide individual element you can do so by specifying them individually as comma separated. Which is a very convenient way of inserting 
some more elements into existing list for example we can add some more asset classes into our existing assetlist as below?

Collections.addAll(assetList, "Equity Derivatives", "Eqity Index Arbitrage" , "Mutual Fund");

3) Example of Converting ArrayList to Array using Collection's addAll method
This is another great way of converting an array to arraylist. We are essentially using Collection interface's addAll() method for copying content from one list
to another. Since List returned by Arrays.asList is fixed-size itís not much of use, this way we can convert that into proper arraylist.


 Arraylist newAssetList = new Arraylist();
 newAssetList.addAll(Arrays.asList(asset));

These were the three methods to convert an array to arraylist. You can also create arrays of ArrayList because list can hold any type of object.


How to convert ArrayList to Array in Java:-->
----------------------------------------------
Now this is a opposite side of story where you want to convert from Arraylist to Array, instead of array to ArrayList interesting right. Just now we were looking at converting array to arraylist and now we need to back to former one. Anyway itís simpler than you have probably thought again we have java.util.Arrays class as our rescue. This class acts as bridge between ArrayList to array.


ArrayList assetTradingList = new ArrayList();                      

assetTradingList.add("Stocks trading");
assetTradingList.add("futures and option trading");
assetTradingList.add("electronic trading");
assetTradingList.add("forex trading");
assetTradingList.add("gold trading");
assetTradingList.add("fixed income bond trading");

String [] assetTradingArray = new String[assetTradingList.size()];

assetTradingArray.toArray(assetTradingArray);

After execution of last line our assetTradingList will be converted into String array. 
------------------------------------------------------
What is the difference between Enumeration and Iterator ?

1) Enumeration is older and its there from JDK1.0 while iterator was introduced later. 
2) Similarity between Iterator and Enumeration in Java is that functionality of Enumeration interface is duplicated by the Iterator interface.
3) Only major difference between Enumeration and iterator is Iterator has a remove() method while Enumeration doesn't. Enumeration acts as Read-only interface, because it has the methods only to traverse and fetch the objects, where as by using Iterator we can manipulate the objects like adding and removing the objects from collection e.g. Arraylist.
4) Also Iterator is more secure and safe as compared to Enumeration because it does not allow other thread to modify the collection object while some thread is iterating over it and throws ConcurrentModificationException. This is by far most important fact for me for deciding between Iterator vs Enumeration in Java.

In Summary both Enumeration and Iterator will give successive elements, but Iterator is new and improved version where method names are shorter, and has new method
called remove. Here is a short comparison:

---------------------------------------------------------------------------------

Collection Interview Questions Answers: -->
----------------------------------------


Quest: What is difference between fail-fast and fail-safe Iterators?
Ans  : Fail-fast Iterators throws ConcurrentModificationException when one Thread is iterating over collection object and other thread structurally modify Collection either by 	
       adding or removing objects on underlying collection. They are called fail-fast because they try to immediately throw Exception when they encounter failure.
       On the other hand fail-safe Iterators works on copy of collection instead of original collection.

Quest : What is difference between Synchronized Collection and ConcurrentCollection?
Ans   : Java5 has added several new ConcurrentCollection classes e.g. ConcurrentHashMap, CopyOnWriteArrayList, BlockingQueue etc, Java also provided way to get Synchronized copy of 
        collection e.g. ArrayList, HashMap by using Collections.synchronizedMap() Utility function. One Significant difference is that ConccurentCollections has better performance than synchronized Collection because they lock only a portion of Map to achieve concurrency and Synchronization.
	
Quest: What is difference between Iterator and Enumeration?
Ans : 1. Iterator duplicate functionality of Enumeration with one addition of remove() method and both provide navigation functionally on objects of Collection.
      2. Iterator is more safe than Enumeration and doesn't allow another thread to modify collection object during iteration except remove() method  
         and throws ConcurrentModificaitonException. See Iterator vs Enumeraiton in Java for more differences.


Quest : When do you use ConcurrentHashMap ?
Ans   : ConcurrentHashMap is better suited for situation where you have multiple readers and one Writer or fewer writers since Map gets locked only during write operation. If you have equal number of reader and writer than ConcurrentHashMap will perform in line of HashTable or synchronized hashMap.

Quest : How do you Sort objects on collection?
Ans   : This Collection interview question serves two purpose it not only test an important programming concept Sorting but Also utility class like Collections which provide several methods for creating synchronized collection and sorting. Sorting is implemented using Comparable or Comparator and when you call Collections.sort() it gets sorted based on natural order specified in CompareTo method while Collections.sort(Comparator) will sort objects based on compare() method of Comparator. See Sorting in Java using Comparator and Comparable for more details.

Quest: What is the difference between Enumeration and Iterator ?
Ans : 
1) Enumeration is older and its there from JDK1.0 while iterator was introduced later. 
2) Similarity between Iterator and Enumeration in Java is that functionality of Enumeration interface is duplicated by the Iterator interface.
3) Only major difference between Enumeration and iterator is Iterator has a remove() method while Enumeration doesn't. Enumeration acts as Read-only interface,because it has the methods only to traverse and fetch the objects, where as by using Iterator we can manipulate the objects like adding and removing the objects from collection e.g. Arraylist.
4) Also Iterator is more secure and safe as compared to Enumeration because it does not allow other thread to modify the collection object while some thread is iterating over it and throws ConcurrentModificationException if modification happens. This is by far most important fact for me for deciding between Iterator vs Enumeration in Java.

In Summary both Enumeration and Iterator will give successive elements, but Iterator is new and improved version where method names are shorter, and has new method called remove. Here is a short comparison:

Enumeration:-->
hasMoreElement()
nextElement()
N/A

Iterator:-->
hasNext()
next()
remove()

So Enumeration is used when ever we want to make Collection objects as Read-only.


---------------------------------------------------------------------------------------------------------------


Top 5 Concurrent Collections from JDK 5 and 6 Java Programmer Should Know :-->
----------------------------------------------------------------------------
1. ConcurrentHashMap:-->
--------------------
http://www.javamadesoeasy.com/2015/04/concurrenthashmap-in-java.html
http://javabypatel.blogspot.in/2016/09/concurrenthashmap-interview-questions.html

ConcurrentHashMap provides an alternative of HashTable or Synchronized Map classes with supports of higher level of concurrency by implementing fine grained locking. Multiple readers can access the Map concurrently while a portion of Map gets locked to write operation depends upon concurrency level of Map. 
ConcurrentHashMap provides better scalability than their synchronized counter part. Iterator of ConcurrentHashMap are fail-safe iterators which doesn't throw ConcurrencModificationException thus eliminates another requirement of locking during iteration which result in further scalability and performance.

	How ConcurrentHashMap is implemented in Java:==>
	----------------------------------------------
    ConcurrentHashMap is thread -safe and is introduced as an alternative of HashTable or synchronized HashMap and provided all functions supported by HashTable with additional feature called "concurrency level", which allows ConcurrentHashMap to partition Map. ConcurrentHashMap allows multiple readers to read concurrently without any blocking while portion of Map is being modified.
	This is achieved by partitioning Map into different parts based on concurrency level and locking only a portion of Map during updates. Default concurrency level is 16, and accordingly Map is divided into 16 parts and each part is governed with different lock. This means, 16 thread can operate on Map simultaneously, until they are operating on different part of Map. This makes ConcurrentHashMap high performance despite keeping thread-safety intact. Though, it comes with caveat. 
	Since update operations like put(), remove(), putAll() or clear() are not synchronized, concurrent retrieval may not reflect most recent change on Map.
	In case of putAll() or clear(), which operates on whole Map, concurrent read may reflect insertion and removal of only some entries.

	ConcurrentHashMap putifAbsent example in Java:==>
	-----------------------------------------------	
	 ConcurrentHashMap examples are similar to HashTable examples, we have seen earlier, but worth knowing is use of putIfAbsent() method. Many times we need to insert entry into Map, if its not present already, and we wrote following kind of code:
		
	  synchronized(map){
		 if (map.get(key) == null){
		   return map.put(key, value);
		 } else{
		   return map.get(key);
		}
	 }
	 Though this code will work fine in HashMap and HashTable, This won't work in ConcurrentHashMap; because, during put operation whole map is not locked, and 
	 while one thread is putting value, other thread's get() call can still return null which result in one thread overriding value inserted by other thread.
	 Ofcourse,you can wrap whole code in synchronized block and make it thread-safe but that will only make your code single threaded. ConcurrentHashMap provides putIfAbsent(key, value) which does same thing but atomically and thus eliminates above race condition.

	When to use ConcurrentHashMap in Java :==>
	------------------------------------------
	1. ConcurrentHashMap is best suited when you have multiple readers and few writers. If writers more or equal to reader, than performance of ConcurrentHashMap effectively reduces to synchronized map or HashTable.
	2. ConcurrentHashMap is a good choice for caches, which can be initialized during application start up and later accessed by many requests processing threads.

	Summary :==>
	-----------
	1. ConcurrentHashMap allows concurrent read and thread-safe update operation.
	2. During update operation, ConcurrentHashMap only lock a portion of Map instead of whole Map.
	3. Concurrent update is achieved by internally dividing Map into small portions which is defined by concurrency level.
	4. Choose concurrency level carefully as a significant higher number can be waste of time and space and lower number may introduce thread contention in case writers over number concurrency level.
	5. All operations of ConcurrentHashMap are thread-safe.
	6. Since ConcurrentHashMap implementation doesn't lock whole Map, there is chance of read overlapping with update operations like put() and remove(). In that case result returned by get() method will reflect most recently completed operation from there start.
	7. Iterator returned by ConcurrentHashMap is weekly consistent, fail safe and never throw ConcurrentModificationException.
	8. ConcurrentHashMap doesn't allow null as key or value.
	9. You can use ConcurrentHashMap in place of HashTable but with caution as CHM doesn't lock whole Map.
	10. During putAll() and clear() operations, concurrent read may only reflect insertion or deletion of some entries.

	Example : ConcurrentHashMapClass.java
	
Quest :  Can multiple threads read and write from same or different Segments of ConcurrentHashMap simultaneously?	
         Say T1 is writing data in Segment 1 and T2 is reading data from same Segment 1, can read be allowed while writing operation is going on?
		 Read-Write Operation: get and put
Ans : YES. Both operation that is T1 writing and T2 reading can be done parallely. 

Quest : What data will T2 read if T1 is updating same data?
ANs :   Retrieval operations (including get) generally do not block, so may overlap with update operations (including put and remove). 
Latest updated value present will be returned by get operation that is value updated by most recently completed update operationswill be returned.

Note: Get operations are lock free and can be performed simulateneously irrespective of other thread writing data on same or different Segment of CHM.	

		
2. CopyOnWriteArrayList and CopyOnWriteArraySet :--> 
-----------------------------------------------
CopyOnWriteArrayList implements List interface like ArrayList, Vector and LinkedList but it is a thread-safe collection and it achieves its thread-safety in a slightly different way than Vector or other thread-safe collection class.
 As name suggest CopyOnWriteArrayList creates copy of underlying ArrayList with every mutation operation e.g. add or set. Normally CopyOnWriteArrayList is very expensive because it involves costly Array copy with every write operation
 but its very efficient if you have a List where Iteration outnumber mutation e.g. you mostly need to iterate the list and don't modify it too often. 
Iterator of CopyOnWriteArrayList is fail-safe and doesn't throw ConcurrentModificationException even if underlying CopyOnWriteArrayList is modified once Iteration begins because Iterator is operating on separate copy of ArrayList.

*Consequently all the updates made on CopyOnWriteArrayList is not available to Iterator. 
	
	 Difference between CopyOnWriteArrayList and ArrayList:==>
	-----------------------------------------------------
	1) First and foremost difference between them is that CopyOnWriteArrayList is a thread-safe collection while ArrayList is not thread-safe and can not be used in multi-threaded environment.
	2) Iterator of ArrayList is fail-fast and throw ConcurrentModificationException once detect any modification in List after iteration begins but Iterator of CopyOnWriteArrayList is fail-safe and doesn't throw ConcurrentModificationException.
	3) Iterator of CopyOnWriteArrayList doesn`t have remove() method.

	Example : com.collections.advance.CopyOnWriteArrayListExample.java
		
	CopyOnWriteArraySet :==>
	-----------------------
	As the name suggests, the CopyOnWriteArraySet class is a replacement for the standard Set class. It uses an internal CopyOnWriteArrayList for all of its operations. Thus, it shares the same basic properties:
	1) It is best suited for applications in which set sizes generally stay small, read-only operations vastly outnumber mutative operations, and you need to 
	   prevent interference among threads during traversal.
    2) It is thread-safe.
    3) Mutative operations (add, set, remove, etc.) are expensive since they usually entail copying the entire underlying array.
    4) Iterators do not support the mutative remove operation.
    5) Traversal via iterators is fast and cannot encounter interference from other threads. Iterators rely on unchanging snapshots of the array at the time the
       iterators were constructed.
	   
	   Example : CopyOnWriteArraySetExample.jva
	
3. BlockingQueue :-->
----------------
BlockingQueue is a unique collection type which not only store elements but also supports flow control by introducing blocking if either BlockingQueue is full or empty. 
put() method of BlockingQueue will block if Queue is full and take() method of BlockingQueue will block if Queue is empty . This property makes BlockingQueue an ideal choice for implementing Producer consumer design pattern where one thread inserts element into BlockingQueue and other thread consumes it.
Java 5 also provides PriorityBlockingQueue, another implementation of BlockingQueue which is ordered on priority and useful if you want to process elements on order other than FIFO.
BlockingQueue doesnít accept null values and throw NullPointerException if you try to store null value in the queue.

	Important properties of BlockingQueue in Java :==>
	------------------------------------------------
	1) BlockingQueue in Java doesn't allow null elements, various implementation of BlockingQueue like ArrayBlockingQueue, LinkedBlockingQueue throws NullPointerException when you try to add null on queue.

		BlockingQueue<String> bQueue = new ArrayBlockingQueue<String>(10);
		//bQueue.put(null); //NullPointerException - BlockingQueue in Java doesn't allow null
     
		bQueue = new LinkedBlockingQueue<String>();
		bQueue.put(null);

		Exception in thread "main" java.lang.NullPointerException
				at java.util.concurrent.LinkedBlockingQueue.put(LinkedBlockingQueue.java:288)
		
		Example : BlockingQueueTest.java
				
	 2) BlockingQueue can be bounded or unbounded. A bounded BlockingQueue is one which is initialized with initial capacity and call to put() will be blocked if BlockingQueue is full or size is equal to capacity. This bounding nature makes it ideal to use as shared queue between multiple threads like in most common Producer consumer solutions in Java. 
		An unbounded Queue is one which is initialized without capacity, actually by default it initialized with Integer.MAX_VALUE. 
		
BlockingQueue uses bounded BlockingQueue as shown in below example.

	 BlockingQueue<String> bQueue = new ArrayBlockingQueue<String>(2);
		bQueue.put("Java");
		System.out.println("Item 1 inserted into BlockingQueue");
		bQueue.put("JDK");
		System.out.println("Item 2 is inserted on BlockingQueue");
		bQueue.put("J2SE");
		System.out.println("Done");

		Output:
		Item 1 inserted into BlockingQueue
		Item 2 is inserted on BlockingQueue
		
		This code will only insert Java and JDK into BlockingQueue and then it will block while inserting 3rd element J2SE because size of BlockingQueue is 2.
		Done will not get printed until any thread calls take() method to remove the element from queue.	
		
		Example : ArrayBlockingQueueTest.java
	
   3) BlockingQueue implementations like ArrayBlockingQueue, LinkedBlockingQueue and PriorityBlockingQueue are thread-safe. All queuing method uses concurrency control and internal locks to perform operation atomically. Since BlockingQueue also extend Collection, bulk Collection operations like addAll(), containsAll() are not performed atomically until any BlockingQueue implementation specifically supports it. So call to addAll() may fail after inserting couple of elements.

   4) Common methods of BlockingQueue are put() and take() which are blocking methods in Java and used to insert and retrieve elements from BlockingQueue.
	put() will block if BlockingQueue is full and take() will block if BlockingQueue is empty, call to take() removes element from head of Queue as shown in following example:

	BlockingQueue<String> bQueue = new ArrayBlockingQueue<String>(2);
			bQueue.put("Java"); //insert object into BlockingQueue
			bQueue.put("J2EE"); //insert object into BlockingQueue
			System.out.println("BlockingQueue after put: " + bQueue.toString());
			bQueue.take(); //retrieve object from BlockingQueue in Java
			System.out.println("BlockingQueue after take: " + bQueue);
		    
	Output:
		BlockingQueue after put: [Java, J2EE]
		BlockingQueue after take: [J2EE]

	Example : BlockingQueuePutTakeTest.java

	5) BlockingQueue interface extends Collection, Queue and Iterable interface which provides it all Collection and Queue related methods like poll() and peak(), unlike take(), peek() method returns head of the queue without removing it, poll() also retrieves and removes elements from head but can wait till specified time if Queue is empty.

	BlockingQueue<String> linkedBQueue = new LinkedBlockingQueue<String>(2);
		linkedBQueue.put("Java"); //puts object into BlockingQueue
		System.out.println("size of BlockingQueue before peek : " + linkedBQueue.size());      
		System.out.println("example of peek() in BlockingQueue: " + linkedBQueue.peek());
		System.out.println("size of BlockingQueue after peek : " + linkedBQueue.size());
		System.out.println("calling poll() on BlockingQueue: " + linkedBQueue.poll());
		System.out.println("size of BlockingQueue after poll : " + linkedBQueue.size());
	
		Output:
		size of BlockingQueue before peek : 1
		example of peek() in BlockingQueue: Java
		size of BlockingQueue after peek : 1
		calling poll() on BlockingQueue: Java
		size of BlockingQueue after poll : 0
	
Note : Peek() : This method is used to retrieve the head of this queue but it does not remove it , return null if this queue is empty.
       Poll() : The poll() method is used to retrieve and remove the head of this queue, or returns null if this queue is empty. 	
	
	Example : BlockingQueuePeekPollMethodsTest.java
	
	6) Other important methods from BlockingQueue in Java is remainingCapacity() and offer().
      remainingCapacity() returns number of remaining space in BlockingQueue, which can be filled without blocking.
	  offer() insert object into queue if possible and return true if success and false if fail unlike add() method which throws IllegalStateException if it fails to insert object into BlockingQueue. Use offer() over add() wherever possible.

	Usage of BlockingQueue in Java:==>
	--------------------------------
	There can be many creative usage of BlockingQueue in Java given its flow control ability. Two of the most common ways I see programmer uses BlockingQueue is to implement Producer Consumer design pattern and implementing Bounded buffer in Java. It surprisingly made coding and inter thread communication over a shared object very easy.

	ArrayBlockingQueue and LinkedBlockingQueue in Java:==>
	----------------------------------------------------
	ArrayBlockingQueue and LinkedBlockingQueue are common implementation of BlockingQueue<E> interface. ArrayBlockingQueue is backed by array and Queue impose orders as FIFO. 
	head of the queue is the oldest element in terms of time and tail of the queue is youngest element. 
	ArrayBlockingQueue is fixed size bounded buffer on the other hand LinkedBlockingQueue is an optionally bounded queue built on top of Linked nodes.
	In terms of throughput LinkedBlockingQueue provides higher throughput than ArrayBlockingQueue in Java.

	Example : com.threads.producerconsumer1 or com.threads.producerconsumer
		
BlockingQueue Example implementing Producer Consumer Problem :-->
-------------------------------------------------------------------
* java.util.concurrent.BlockingQueue is a Queue that supports operations that wait for the queue to become non-empty when retrieving and removing an element, and wait for space to become available in the queue when adding an element.

* BlockingQueue doesnít accept null values and throw NullPointerException if you try to store null value in the queue.

* BlockingQueue implementations are thread-safe. All queuing methods are atomic in nature and use internal locks or other forms of concurrency control.

* BlockingQueue interface is part of java collections framework and itís primarily used for implementing producer consumer problem. We donít need to worry about waiting for the space to be available for producer or object to be available for consumer in BlockingQueue as itís handled by implementation classes of BlockingQueue.

* Java provides several BlockingQueue implementations such as ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue etc.

* While implementing producer consumer problem, we will use ArrayBlockingQueue implementation and following methods are important to know.

    put(E e): This method is used to insert elements to the queue, if the queue is full it waits for the space to be available.
    E take(): This method retrieves and remove the element from the head of the queue, if queue is empty it waits for the element to be available.

	Example : com.threads.producerconsumer1
	
Example is present in the below package for wait,notify and notifyAll methods.	
com.threads.producerconsumer.waitnotify

Producer Consumer without BlockingQueue is given below:

4.Deque and BlockingDeque:-->
--------------------------
Deque interface is added in Java 6 and it extends Queue interface to support insertion and removal from both end of Queue referred as head and tail. 
Java6 also provides concurrent implementation of Deque like ArrayDeque and LinkedBlockingDeque. Deque Can be used efficiently to
increase parallelism in program by allowing set of worker thread to help each other by taking some of work load from other 
thread by utilizing Deque double end consumption property. So if all Thread has there own set of task Queue and they are 
consuming from head; helper thread can also share some work load via consumption from tail.


5. ConcurrentSkipListMap and ConcurrentSkipListSet:-->
---------------------------------------------------
Just like ConcurrentHashMap provides a concurrent alternative of synchronized HashMap. ConcurrentSkipListMap and ConcurrentSkipListSet provide concurrent alternative
for synchronized version of SortedMap and SortedSet. For example instead of using TreeMap or TreeSet wrapped inside synchronized Collection, You can consider using
ConcurrentSkipListMap or ConcurrentSkipListSet from java.util.concurrent package. They also implement NavigableMap and NavigableSet to add additional navigation
method we have seen in our post How to use NavigableMap in Java.


----------------------------------------------------------------------

Difference between ConcurrentHashMap and Collections.synchronizedMap and HashTable:-->
--------------------------------------------------------------------------------
JDK 1.5 introduces some good concurrent collections which is highly efficient for high volume, low latency system electronic trading systems In general those are backbone for Concurrent fast access of stored data. 

Why we need ConcurrentHashMap and CopyOnWriteArrayList
The synchronized collections classes, HashTable and Vector, and the synchronized wrapper classes, Collections.synchronizedMap and Collections.synchronizedList provide a basic conditionally thread-safe implementation of Map and List. However, several factors make them unsuitable for use in highly concurrent applications for example their single collection-wide lock is an impediment to scalability and it often becomes necessary to lock a collection for a considerable time during iteration to prevent ConcurrentModificationException.

ConcurrentHashMap and CopyOnWriteArrayList implementations provide much higher concurrency while preserving thread safety, with some minor compromises in their promises to callers. ConcurrentHashMap and CopyOnWriteArrayList are not necessarily useful everywhere you might use HashMap or ArrayList, but are designed to optimize specific common situations. Many concurrent applications will benefit from their use.

difference between concurrentHashMap, HashTable and Synchronized Map

So what is the difference between HashTable and ConcurrentHashMap , both can be used in multithreaded environment but once the size of HashTable becomes considerable large performance degrade because for iteration it has to be locked for longer duration.

Since ConcurrentHashMap introduced concept of segmentation , how large it becomes, only certain part of it gets locked to provide thread safety so many other readers can still access map without waiting for iteration to complete.

***In Summary ConcurrentHashMap only locked certain portion of Map while HashTable lock full map while doing iteration. 

Difference between ConcurrentHashMap and Collections.synchronizedMap
ConcurrentHashMap is designed for concurrency and improve performance while HashMap which is non synchronized by nature can be synchronized by applying a wrapper using Collections.synchronizedMap. Here are some of common differences between ConcurrentHashMap and Collections.synchronizedMap

ConcurrentHashMap do not allow null keys or null values while HashMap allows null keys.

-----------------------------------------------


Least Recently Used (LRU) cache:
----------------------------------
https://www.geeksforgeeks.org/lru-cache-implementation/

LRU can be used in order to manage a cache of information stored on the computer.
Initially, when the cache has room for more pages, we keep on adding the pages to the cache. But when cache is completely filled, then to add a new page, another page has to be removed. So, a strategy needs to be used for replacing cache pages.
Least Recently Used cache replacement algorithm is a cache replacement strategy by which the least recently accessed page is removed from the cache when a new page is accessed which is not already present in the cache.

We use two data structures to implement an LRU Cache.
1. Queue which is implemented using a doubly linked list.  The maximum size of the queue will be equal to the total number of frames available (cache size).The most recently used pages will be near front end and least recently pages will be near rear end. 
2. A Hash with page number as key and address of the corresponding queue node as value.

Example : com.ds.lru.LRUCache
Example : 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5

Enteries -> 1	  2     3         4        1       2   		 5        1       2        3        4        5   	
Cache    -> 1 -> 2,1 -> 3,2,1 -> 4,3,2 -> 1,4,3 -> 2,1,4 -> 5,2,1 -> 1,5,2 -> 2,1,5 -> 3,2,1 -> 4,3,2 -> 5,4,3 
	
	
----------------------------------------------------------------------------------------------------------------------

Topic			                     :: Comparator and Comparable ::


Que : How to use Comparator and Comparable in Java? With example
Ans : Comparators and comparable in Java are two interfaces which are used to implement sorting in Java. Itís often required to sort objects stored in any collection classes like ArrayList, HashSet or in Array than we need to use either compare() or compareTo() method defined in java.util.Comparator and java.lang.Comparable. 

Comparator vs Comparable :-->
-------------------------
1) Comparator in Java is defined in java.util package while Comparable interface is defined in java.lang package, which very much says that Comparator should be used as an utility to sort objects but Comparable should be provided by default.

2) Comparator interface in Java has method public int compare (Object o1, Object o2) which returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. While Comparable interface has method public int compareTo(Object o) which returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.
  
3) If you see then logical difference between these two is, Comparator compares two objects provided to it, while Comparable interface compares "this" reference with the object specified.

4) Comparable is used to implement natural ordering of object. In Java API String, Date and wrapper classes implements Comparable interface.Its always good practice to override compareTo() for value objects in collection.

5) If any class implement Comparable interface then collection of that object either List or Array can be sorted automatically by using Collections.sort() or Arrays.sort() method and object will be sorted based on there natural order defined by CompareTo() method.

6) Objects which implement Comparable in Java can be used as keys in a SortedMap like TreeMap or elements in a SortedSet for example TreeSet, without specifying any Comparator.

Example : Person.java
***Summary if you want to sort objects based on natural order then use Comparable and if you want to sort on some other attribute of object then use Comparator.

1) There is class called Person, sort the Person based on person_id, which is primary key in database
2) Sort the Person based on there name.

For a Person class, sorting based on person_id can be treated as natural order sorting and sorting based on name field can be implemented using Comparator interface.
To sort based on person_id we need to implement compareTo() method.

public class Person implements Comparable {
    private int person_id;
    private String name;
   
    /**
     * Compare current person with specified person
     * return zero if person_id for both person is same
     * return negative if current person_id is less than specified one
     * return positive if specified person_id is greater than specified one
     */
    @Override
    public int compareTo(Object o) {
        Person p = (Person) o;
        return this.person_id - p.person_id ;
    }
    Ö.
}

Generally you should not use difference of integers to decide output of compareTo method as result of integer subtraction can overflow but if you are sure that both operands are positive then its one of the quickest way to compare two objects and for sorting based on person name we can implement compare(Object o1, Object o2) method of Java Comparator class.

/**
 * Comparator implementation which sorts Person objects on person_id field
 */
public class SortByPerson_ID implements Comparator{

    public int compare(Object o1, Object o2) {
        Person p1 = (Person) o;
        Person p2 = (Person) o;
        return p1.getPersonId() - p2.getPersonId();
    }
}

Similar guidelines applies while implementing compare() method as well and instead of using subtraction operator, its better to use logical operator to compare whether two integers are equal to, less than or greater than. You can write several types of Java Comparator based upon your need for example reverseComparator , ANDComparator , ORComparator etc which will return negative or positive number based upon logical results.
String in Java even provides an special comparator called CASE_INSENSITIVE_ORDER, to perform case insensitive comparison of String objects.

How to Compare String in Java:---> 
----------------------------- 
For comparing String in Java we should not be worrying because String implements Comparable interface and provides a lexicographic implementation for CompareTo method which compare two strings based on contents of characters or you can say in lexical order. You just need to call String.compareTo(AnotherString) and Java will determine whether specified String is greater than,equal to or less than current object.
Example:StringCompareUsingCompareTo.java

How to Compare Dates in Java:---> Dates are represented by java.util.Date class in Java. Date also implements Comparable in Java so they will be automatically sorted based on there natural ordering if they got stored in any sorted collection like TreeSet or TreeMap. 
If you explicitly wants to compare two dates in Java you can call Date.compareTo(AnotherDate) method in Java and it will tell whether specified date is greater than, equal to or less than current String.

When to use Comparator and Comparable :-->
------------------------------------
1) If there is a natural or default way of sorting Object already decided during development of Class than use Comparable. This is intuitive and you given the class name people should be able to guess it correctly like Strings are sorted chronically,Employee can be sorted by there Id etc. On the other hand if an Object needs to be sorted on multiple ways and client is specifying on which parameter sorting should take place than use Comparator interface.
for example Employee can again be sorted on name, salary or department and clients needs an API to do that. Comparator implementation can sort out this problem.

2) Some time you write code to sort object of a class for which you are not the original author, or you don't have access to code. In these cases you can not implement Comparable and Comparator is only way to sort those objects.

3) Beware with the fact that How those object will behave if stored in SorteSet or SortedMap like TreeSet and TreeMap. If an object doesn't implement Comparable than while putting them into SortedMap, always provide corresponding Comparator which can provide sorting logic.

4) Order of comparison is very important while implementing Comparable or Comparator interface. for example if you are sorting object based upon name than you can compare first name or last name on any order, so decide it judiciously.

5) Comparator has a distinct advantage of being self descriptive for example if you are writing Comparator to compare two Employees based upon their salary than name that comparator as SalaryComparator, on the other hand compareTo()


Example : Testing.java


-----------------------------------------------------------------------------------------------------------


        Topic                                   ::equals() and hashCode()::

How to override equals and hashCode method :-->

Equals and hashCode in Java are two fundamental method which is declared in Object class and part of core Java library.
equals() method is used to compare Objects for equality while hashCode is used to generate an integer code corresponding to that object.equals and 
hashCode are used extensively used while inserting and retrieving Object in HashMap, equals method is also used to avoid duplicates on HashSet and other Set implementation and every other place where you need to compare Objects. 

Default implementation of equals() provided by java.lang.Object to compare memory location of Objects and returns true only if two reference variable are pointing to same memory location i.e. essentially they are same object. many classes in Java standard library does override it e.g. String overrides equals,whose implementation of equals() method return true if content of two String objects are exactly same. Integer wrapper class overrides equals to perform numerical comparison etc.
Since HashMap and HashTable in Java relies on equals() and hashCode() method for comparing keys and values, Java provides following rules to override equals method.

As per following rule equals method in Java should be:

1) Reflexive : Object must be equal to itself.
2) Symmetric : if a.equals(b) is true then b.equals(a) must be true.
3) Transitive : if a.equals(b) is true and b.equals(c) is true then c.equals(a) must be true.
4) Consistent : multiple invocation of equals() method must result same value until any of properties are modified. So if two objects are equals they will remain equals until any of 
   their property is modified.
5) Null comparison : comparing any object to null must be false and should not result in NullPointerException. For example a.equals(null) must be false,
   passing unknown object to equals which could be null.

Equals and hashCode contract in Java --->
equals method in Java must follow its contract with hashCode method as explained below.

1) If two objects are equal by equals() method then there hashcode must be same.
2) If two objects are not equal by equals() method then there hashcode could be same or different.

Steps to Override equals method in Java:

1) Do this check -- if yes then return true.
2) Do null check -- if yes then return false.
3) Do the instanceof check,  if instanceof return false than return false from equals() method,
	After some research I found that instead of instanceof we can use getClass() method for type identification because instanceof check returns true for subclass also, so its not strictly equals comparison until required by business logic but instanceof check is fine if your class is immutable and no one is going to sub class it. 
	For example we can replace instanceof check by below code:

if((obj == null) || (obj.getClass() != this.getClass()))
        return false;

4) Type cast the object; note the sequence,the instanceof check must be prior to casting object.

5) Compare individual attribute starting with numeric attribute because comparing numeric attribute is fast and use short circuit operator for combining checks.
   If first field does not match, don't try to match rest of attribute and return false. Itís also worth to remember doing null check on individual attribute before calling equals() method on them recursively to avoid NullPointerException during equals check in Java.

See Example : PersonToStringAndHashCode.java


Code Example of overriding equals method in Java

/**
 * Person class with equals and hashcode implementation in Java
 * @author Javin Paul
 */
public class Person {
    private int id;
    private String firstName;
    private String lastName;

    public int getId() { return id; }
    public void setId(int id) { this.id = id;}

    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }

    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj == null || obj.getClass() != this.getClass()) {
            return false;
        }

        Person guest = (Person) obj;
        return ( id == guest.id) 
                && (firstName == guest.firstName || (firstName != null && firstName.equals(guest.getFirstName())))
                && (lastName == guest.lastName   || (lastName != null && lastName .equals(guest.getLastName())));
    }
           
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());
        result = prime * result + id;
        result = prime * result + ((lastName == null) ? 0 : lastName.hashCode());
        return result;
    }
   
}

If you look above method we are first checking for "this" check which is fastest available check for equals method then we are verifying whether object is null or not and object is of same type or not. only after verifying type of object we are casting it into desired object to avoid any ClassCastException . Also while comparing individual attribute we are comparing numeric attribute first using short circuit operator to avoid further calculation if its already unequal and doing null check on member attribute to avoid  NullPointerException.           
           
Common Errors while overriding equals in Java -->
Donít use float and double for monetary calculation and Mixing static and non static synchronized method. 

1) Instead of overriding equals() method programmer overloaded it.
This is the most common error I have seen while overriding equals method . Syntax of equals method defined in Object class is public boolean equals(Object obj)
but many people unintentionally overloads equals method in Java by writing public boolean equals(Person obj), instead of using Object as argument they use there
class name. This error is very hard to detect because of static binding. So if you call this method in your class object it will not only compile but also execute
correctly but if you try to put your object in collection e.g. ArrayList and call contains() method which is based on equals() method then it will not able to
detect your object. So beware of it. This question is also a frequently asked question in Java interviews as part of Overloading vs Overriding as how do you
prevent this from happening ? Thankfully along with Generics, Enum, autoboxing and varargs in Java 5 also introduces @Override annotation which can be used to tell 
compiler that you are overriding a method and than compiler will be able to detect this error during compile time. Consistently using @Override annotation is also a
best practice .


2) Second mistake I have seen while overriding equals() method is not doing null check for member variables which ultimately results in NullPointerException during equals() invocation. For example in above code correct way of calling equals() method of member variable is after doing null check as shown below:

firstname == guest.firstname || (firstname != null && firstname.equals(guest.firstname)));


3) Third common mistake is not overriding hashCode method in Java and only overriding equals() method. You must have to override both equals() and hashCode() method
in Java , otherwise your value object will not be able to use as key object in HashMap because working of HashMap is based on equals() and hashCode to read more see
How HashMap works in Java.

4) Last common mistake programmer makes while overriding equals() is not keeping equals() and compareTo() method consistent which is a non formal requirement in order to obey contract of Set to avoid duplicates. SortedSet implementation like TreeSet uses compareTo() to compare two objects like String and if compareTo() and equals() will not be consistent than TreeSet will allow duplicates which will break Set contract of not having duplicates. To learn more about this issue see my post "Things to remember while overriding compareTo in Java".

-------------------------------------

How to override hashcode in Java:-->
--------------------------------
Importance of hashcode increases when we use the object in different collection classes which works on hashing principle e.g. HashTable and hashmap. A well written hashcode method can improve performance drastically by distributing objects uniformly and avoiding collision. 

General Contracts for hashCode() in Java
1) If two objects are equal by equals() method then their hashcode returned by hashCode() method must be same.

2) Whenever hashCode() method is invoked on the same object more than once within single execution of application, hashCode() must return same integer provided no information or fields used in equals and hashcode is modified.This integer is not required to be same during multiple execution of application though.

3) If two objects are not equals by equals() method it is not require that there hashcode would be different. Though itís always good practice to return different hashCode for unequal object. Different hashCode for distinct object can improve performance of hashmap or HashTable by reducing collision.

Overriding hashCode method in Java

1) Take a prime hash e.g. 5, 7, 17 or 31 (prime number as hash, results in distinct hashcode for distinct object)
2) Take another prime as multiplier different than hash is good.
3) Compute hashcode for each member and add them into final hash. Repeat this for all members which participated in equals.
4) Return hash

  Here is an example of hashCode() method

   	    @Override
	    public int hashCode() {
	        final int prime = 31;
	        int result = 1;
	        result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());
	        result = prime * result + id;
	        result = prime * result + ((lastName == null) ? 0 : lastName.hashCode());
	        return result;
	    }

Itís always good to check null before calling hashCode() method on members or fields to avoid NullPointerException, if member is null than return zero.

Example : PersonToStringAndHashCode.java


Index Calculation in Hashmap:
----------------------------
Hash code of key may be large enough to create an array. hash code generated may be in the range of integer and if we create arrays for such a range, then it will easily cause outOfMemoryException. So we generate index to minimize the size of array. Basically following operation is performed to calculate index.

index = hashCode(key) & (n-1).    where n is number of buckets or the size of array. In our example, I will consider n as default size that is 16.


0 & 0 = 0
0 & 1 = 0
1 & 0 = 0
1 & 1 = 1

---------------------------------------------------------------------------------------------
Quest: What is Big-O notation? Give some examples?
Ans : The Big-O notation describes the performance of an algorithm in terms of number of elements in a data structure. Since Collection classes are actually data structures, we usually tend to use Big-O notation to chose the collection implementation to use based on time, memory and performance.

Example 1: ArrayList get(index i) is a constant-time operation and doesnít depend on the number of elements in the list. So itís performance in Big-O notation is O(1).
Example 2: A linear search on array or list performance is O(n) because we need to search through entire list of elements to find the element.


														:: Generics ::

What is Generics in Java
Generics provides compile time type-safety of code and removes risk of ClassCastException at runtime which was quite frequent error in Java code, Also Generics make code clean since we donít need to use casting and instanceOf operator. 

For example HashSet of String will only contain String object and if you try to put Integer or any other object, compiler will complain. Before Java 5 same code will pass compile time check but will fail at runtime which is worse. Generics allows Java programmer to write more robust and type-safe code.but also gives more readability and deterministic behaviour from code.

[How Generics works in Java
The buzzing keyword is "Type Erasure", you guessed it right itís the same thing we used to in our schools for erasing our mistakes in writing or drawing :).
Same thing is done by Java compiler, when it sees code  written using Generics it completely erases that code and covert it into raw type i.e. code without
Generics. All type related information is removed during erasing. So your ArrayList<Gold> becomes plain old ArrayList  prior to JDK 1.5, formal type parameters
e.g. <K, V> or <E> gets replaced by either Object or Super Class of the Type. Also when the translated code is not type correct compiler inserts a type casting
operator. This all done behind the scene so you don't need to worry about what important to us is that Java compiler guarantees type-safety and flag any 
type-safety relate error during compilation. In short Generics in Java is syntactic sugar and doesnít store any type related information at runtime. 
All type related information is erased by Type Erasure, this was the main requirement while developing Generics feature in order to reuse all Java code written
without Generics.]


Rules and Examples of Generics in Java

1) Parametrized type like Set<T> is subtype of raw type Set and you can assign Set<T> to Set, following code is legal in Java:

Set setOfRawType = new HashSet<String>();
setOfRawType = new HashSet<Integer>();

2) Set<Object> is setOfAnyType, you can assign any subtype set of object type only means you can not assign set Of String or set Of Integer to set Of Object using Generics in Java. object type set can store any type value String, Integer values.

Set<Object> setOfAnyType = new HashSet<Object>(); //legal

setOfAnyType.add("abc"); //legal
setOfAnyType.add(new Float(3.0f)); //legal - <Object> can accept any type

Set<Object> setOfAnyType1 = new HashSet<String>(); // compiler error -
HashSet<Object> setOfAnyType2 = new HashSet<String>(); // compiler error -

3)Set<?> represents SetOfUnknownType and you can assign SetOfString or SetOfInteger to Set<?> as shown in below example of Generics :

Set<?> setOfUnknownType = new LinkedHashSet<String>();
setOfUnknownType = new LinkedHashSet<Integer>();

4)Parametrized Type also follow Inheritance at main Type level means both HashSet<String> and LinkedHashSet<String> are sub types of Set<String> and legal by compiler as shown in following Generics example in Java :

Set<String> setOfString = new HashSet<String>(); //valid in Generics
setOfString = new LinkedHashSet<String>(); // Ok

But Inheritance on type parameter is not supported means Set<Object> will not accept Set<String> as per following Generics code.

Set<Object> SetOfObject = new HashSet<String>(); //compiler error - incompatible type

5)Set<? extends Number> will store either Number or sub type of Number like Integer, Float. This is an example of bounded wild-cards in Generics.

Set<? extends Number> setOfAllSubTypeOfNumber = new HashSet<Integer>(); //legal - Integer extends Number
setOfAllSubTypeOfNumber = new HashSet<Float>(); //legal - because Float extends Number

6)Set<? super TreeMap> is another example of bounded wildcards, which will store instances of TreeMap or super class of TreeMap. example :

Set<? super TreeMap> setOfAllSuperTypeOfTreeMap = new LinkedHashSet<TreeMap>(); //legal because TreeMap is superType of itself

setOfAllSuperTypeOfTreeMap = new HashSet<SortedMap>(); //legal because SorteMap is super class of TreeMap
setOfAllSuperTypeOfTreeMap = new LinkedHashSet<Map>(); //legal since Map is super type of TreeMap

7) You can not use Generics in .class token, parametrized types like List<String> are not allow along with .class literal.

List.class //legal
List<String>.class  //illegal

This is the one place where you need to use Raw type instead of parametrized type in Java.

8) If you are writing Generics method than you need to declare type parameters in method signature between method modifiers and return type as shown in below
    example :

 public static <T> T identical(T source){
        return source;
 }

failing to declare <T> will result in compile time error. to know more read How to write Generics method in Java

Generics notations and naming Convention:

Generic Term           			Meaning
Set<E>          				Generic Type , E is called formal parameter  
Set<Integer>                    Parametrized type , Integer is actual parameter here
<T extends Comparable>          Bounded type parameter
<T super Comparable>            Bounded type parameter
Set<?>                          Unbounded wildcard
<? extends T>                   Bounded wildcard type
<? Super T>                     Bounded wildcards
Set                             Raw type
<T extends Comparable<T>>       Recursive type bound

T - used to denote type
E - used to denote element
K - keys
V - values
N - for numbers

Array and Generics in Java
1) Arrays doesn't support Generics in Java so you can not create Arrays like T[] which makes gentrifying an existing class hard if you are using arrays. 
   Though there are work around which requires a cast from Object[] to T[] which comes with risk of unchecked cast and warning. For this reason it's better to
   use Collections classes like ArrayList and HashMap over array. by the way those classes are also implemented on top of array in Java but JDK handles there
   type-safety by effectively using generics. here is an example of casting Object array to generic array in Java :

/**
 * Generics and Array doesn't gel very well, Java doesnít allow Generics array like E[]
 * @author Javin Paul
 */
public class GenericVsArray {
 
    public static void main(String args[]){
      Holder<Integer> numbers = new Holder<Integer>(10);
      numbers.add(101);
      System.out.println("Get: " + numbers.get(0));
    }

 
}

/**
 * Generic Holder for holding contents of different object type
 * Generic in Java eliminates casting required while calling get(index) from client code
 * @param <T>
 */
class Holder<T>{
    private T[] contents;
    private int index = 0;
    public Holder(int size){
        //contents = new T[size]; //compiler error - generic array creation
        contents = (T[]) new Object[size]; //workaround - casting Object[] to generic Type
    }
 
    public void add(T content){
        contents[index] = content;
    }
 
    public T get(int index){
        return contents[index];
    }
}

Casting code may generate warning about "unsafe cast" which can be suppressed by using annotation @SuppressWarnings("unchecked") with proper comment that why it
will not compromise type-safety.

Benefits and advantages:

Type-safety
Most important advantage of Generics in Java is type-safety. Collections prior to JDK1.5 are not type-safe because they accept Object type argument which allows
them to catch all type of objects instead of only required type of object. 
For example if you want to create an ArrayList of Stocks and you don't want that
ArrayList also contain any other asset class you can use generics feature of java to create a type-safe collection. Here is an example of using Generics to
create a type-safe ArrayList

ArrayList<Stocks> stockList = new ArrayList<Stocks>();
stockList.add(ìcoinsî); //compiler error , String not allowed

Compiler will guaranteed that only Stock object will be inserted in stockList and will throw compiler error if you try to insert different type of Object.

No Casting :
With Generics you donít need to cast object ,Generics will automatically do that for you. For example here is the code for adding and retrieving an element in List with and without Generics in Java:

List  items = new ArrayList();
items.add("chocolates");
String item = (String) items.get(0)

List<String> items = new ArrayList();
items.add("biscuits");
String item = items.get(0) //no cast required

Since no cast required, result is clear and robust code.

No ClassCastException
With Generics compiler ensures that correct types are added into Java collection classes and no cast is required while retrieving element, So there is no risk of ClassCastException at runtime.

Some important feature of Generics in Java worth remembering:

1) One limitation of Generics in Java is that it can not be applied to primitive type, for example you can not pass primitives in angle bracket that will result
    in compilation error, for Example ArrayList<int> will result in compilation error, This is little counter-intuitive that why auto-boxing can not covert int
    to Integer. If you try same thing with our Generic Holder class you will get following compilation error:

Holder<int> numbers = new Holder<int>(10); //compiler error - unexpected type required: reference found:int

2) Generics in Java eliminates ClassCastException while retrieving objects from Collection, Remember prior to JDK1.5 if you retrieve objects from Collection you
   first check for a particular type and then cast, no need to do it now.

ArrayList<Stocks> stockList = new ArrayList<StockList>();
Stock sony = new Stock("Sony","6758.T");
stockList.add(sony);
Stock retreivedStock = stockList.get(sony); //no cast requires ñ automatic casting by compiler

3) A parametrized class in Java use formal type parameters to retrieve Type information when instance of parametrized class gets created. In below example of 
   generics class in Java <K,V> are formal parameters.

interface Cache <K,V>{
        public V get();
        public V put(K key, V value);
}
As per convention followed on Generics version of Java Collection package we can use <K,V> for key and value type parameters.

4) Generics are often related to Templates in C++, though Unlike "Template" in C++, which creates a new type for each specific parametrized type, 
   parametrized class in Java is only compiled once and more importantly there is just one single class file which is used to create instances for all the
   specific types.

5) Generics in Java can not only apply on Java Classes but also on methods, so you can write your own generics methods in Java as shown on Rules of Generics in 
Java section, here is another example of parametrized method from Java collection package.

boolean add(E o){}

Here E will be replaced by actual type parameter when this method will get called.


6) Another worth noting feature of Generics in Java is its ability to limit Types parameters, for example in parametric declaration of 
   Holder<T extends Closeable>, type parameter list <T extends Closeable> requires that actual parameter T must be either Closeable or sub-type of Closeable.
   This is called bounded type parameters in Generics . this kind of declaration allows you to call method of Closeable interface without casting type parameter
   into Closeable.

7) Type inference : Generics in Java does not support type inference while calling constructor or creating instance of Generic Types until JDK7,
   In Java 7 along with Automatic resource management and String in Switch  also added a new operator called Diamond operator and denoted by <> which facilitate
   type inference while creating instance of Generics classes. this helps to reduce redundancy and clutter. here is an example of Diamond operator in Java7 code:

//prior to JDK 7
HashMap<String, Set<Integer>> contacts = new HashMap<String, Set<Integer>>()

//JDK 7 diamond operator
HashMap<String, Set<Integer>> contacts = new HashMap<>()

code with diamond operator is much cleaner than previous one.

On related note Generics in Java supports type inference while calling Generic methods and this feature can be used to create in combination of Factory design
pattern in Java to create static factory method corresponding to each constructors. for example

//type inference in generic method
public static <K,V> HashMap<K,V> newContacts() {
   return new HashMap<K,V>();
}

so we can replace call to constructor with this static factory method as shown below :

HashMap<String, Set<Integer>> contacts = newContacts();

this can be used as alternative to diamond operator in Java 5 or 6.

Generics can also be used to write parametric classes like Cache<Key, Value> on which type of Key and Value can be specified while creating objects.

Generics wild cards Example in Java

Generics Best Practices in Java

1) Avoid using Raw types for new code. Always use Generics and write parametrized classes and method to get full benefit of compiler checking.

2) Prefer Collection classes over Array in your parametrized class because Generics and Arrays are completely different to each other, Array hold type information at runtime unlike Generics whose type information is erased by type-erasure during run time.

3) Use Bounded type parameter to increase flexibility of method arguments and API

4) Use @SuppressedWarning("unchecked") at as narrow scope as possible like instead of annotating a method, just annotate a line. Also document rational of why this cast is type-safe as code comments.

5) Convert your raw type classes into type-safe parametric class using Generics in Java as and when time allows, that will make code more robust.



---------------------------------------------------------------------------------------------------------------------------
			Topic		                          ::Thread::
			
http://javabypatel.blogspot.in/2017/04/top-25-multithreading-interview-questions-answers-java.html
			
Quest : What are Threads in Java?
Ans   : In Java, when a program requires more than one task to execute in parallel, say for example,

    Reading a data from a local file.
    Reading a data from remote connection.

So Java Threads helps us creating multiple independent path of execution within a program which can run parallely.   


Quest : What is the difference between Process and Thread?
Ans   : A process is a self contained execution environment and it can be seen as a program or application whereas Thread is a single task of execution within the process. 
Java runtime environment runs as a single process which contains different classes and programs as processes. Thread can be called lightweight process as Thread requires less resources to gets created and to exist in the process, 
thread shares the process resources.
 			

Quest : How to implement Thread in Java ?Example of Runnable interface
Ans : There is only one way by which a Thread can be created in java using java.lang.Thread class as shown below,
			Thread thread1 = new Thread();
 
After creating a Thread object, a separate independent path is created but what task this independent path will execute?
How many ways are there to assign task to a thread?
There are mainly 3 ways by which Task can be assigned to a Thread either by,

1) Runnable interface (run() method will be invoked).
2) Thread class (run() method will be invoked).
3) Callable interface (call() method will be invoked).

Que : How to create Thread in Java -"Which way of implementing Thread is better? Extending Thread class or implementing Runnable interface?
Ans : 1) In my opinion implementing Runnable is better because in Java we can only extend one class so if we extend Thread class we can not extend any other class while by implementing Runnable interface we still have that option open with us.
			or
1) If your class provides more functionality rather than just running as Thread, we should extend Thread class to provide a way to run it as Thread. If your class only goal is to run as Thread, you can implement Runnable interface .			

2) Second reason which make sense to me is more on OOPS concept according to OOPS if we extend a class we provide some new feature or functionality , So if the purpose is just to use the run() method to define code its better to use Runnable interface.

3) Loosely-coupled : "implements Runnable" makes the code loosely-coupled and easier to read .
Because the code is split into two classes . Thread class for the thread specific code and your Runnable implementation class for your job that should be run by a thread code.      "extends Thread"  makes the code tightly coupled . Single class contains the thread code as well as the job that needs to be done by the thread. 

4 ) If My class just needs to create/execute Thread and doesn`t need to access Thread`s class APIs then its west of memory to load Thread class instead just use Runnable interface or same purpose so again its depend on the usages of MyThread class.

//implementing Thread by extending Thread class
 public class MyThread extends Thread{      

   public void run(){
      System.out.println(" Thread Running " + Thread.currentThread().getName());
   }
 }

//implementing Thread by implementing Runnable interface

public class MyRunnable implements Runnable{        

    public void run(){
       System.out.println(" Create Thread " + Thread.currentThread().getName());
    }
 }

//starting Thread in Java
Thread mythread = new MyThread(); //Thread created not started
mythread.setName("T1");

Thread myrunnable = new Thread(new MyRunnable(),"T2"); //Thread created      

mythread.start(); //Thread started now but it may or my not be running
myrunnable.start();


class ThreadTask implements Callable<Result> {
  
 public Result call() { 
		 //Your business logic
 }
 
TIP1: Itís not guaranteed that mythread will start before myrunnable it depends upon Thread scheduler.
TIP2: Thread will be said to go on dead state once execution of run() method finished and you can not start that thread again.


Que : Anybody guess what will happen if we call the run() method directly instead of calling start() method ?
Ans : Simple there would be no Error or Exception, run() method will simply be executed in the same Thread and new Thread will not be created. 

Que : What will happen if you call start() method twice in same Thread object e.g.
mythread.start();
mythread.start(); //this line will throw IllegalThreadStateException

Que : What will happen if you donít override Thread class run() method ?
Ans : So nothing will happen if you donít override run() method.

*  Thread class run() method code :

public void run(){

	if(target != null)
		target.run();
}

Above target is set in init() method of Thread class so When we create an instance of Thread class as new TestThread() its set to null, so nothing will happen
if we donít override run() method.
 
Example : com.thread.norun.TestThread

Que : Can Thread be created without any ThreadGroup, I mean can Thread exist independently without associated to any ThreadGroup? 
Ans : No. Thread cannot be created independently, it will be part of atleast one of the Thread Group.
      Generally, while creating Thread we do not associate it to any Thread Group, but internally it will be part of "main" Thread Group.
Example : com.thread.questions.ThreadGroupClass

Que : Say Thread "t1" is spawned from "main" thread, what happen when RuntimeException is thrown from "t1", Will "main" thread continue to run? 
Ans : Yes. "main" thread will continue to run if an exception is thrown from threads that are created within main thread. 
Example : com.thread.questions.Thread1Exception
In above example, RuntimeException thrown by Thread "t1" will not affect "main" thread and it continues to print "ThreadDemo.main()"
In general, Exception thrown by one thread will not affect another thread, as all threads are independent and have different stack.


Que :

Ans : 

Please go through these questions of Multithreading :
http://javabypatel.blogspot.in/2017/04/top-25-multithreading-interview-questions-answers-java.html

Life Cycle or States of Thread :-->
-----------------------------------------
http://www.journaldev.com/1044/life-cycle-of-thread-understanding-thread-states-in-java

Thread States:
-------------
We can create a thread in java and start it but how the thread states change from Runnable to Running to Blocked depends on the OS implementation of thread scheduler and java doesnít have full control on that. Below diagram shows different states of thread in java.

Thread-Lifecycle-States.png or Thread-Lifecycle-States1.png

New:
----
When we create a new Thread object using new operator, thread state is New Thread. At this point, thread is not alive and itís a state internal to Java programming.

Runnable:
--------
When we call start() method on Thread object,then itís state is changed to Runnable and the control is given to Thread scheduler to complete/finish itís execution. Whether to run this thread instantly or keep it in runnable thread pool before running it depends on the OS implementation of thread scheduler.

Running:
--------
When thread start executing, itís state is changed to Running. Thread scheduler picks one of the thread from the runnable thread pool and change itís state to Running and CPU starts executing this thread. A thread can change state to Runnable, Waiting/Blocked or Dead from running state depends on time slicing,  completion of run() method or waiting for some resources.

Blocked/Waiting :
----------------
A thread can be waiting for other thread to finish or it can be waiting for some resources to be available, for example producer consumer problem or waiter notifier implementation or IO resources, then itís state is changed to Waiting. Once the thread wait state is over, itís state is changed to Runnable and itís moved back to runnable thread pool.

Dead:
-----
Once the thread finished executing, itís state is changed to Dead and itís considered to be not alive or the final state of thread.

Thread Scheduler :
-----------------
Thread scheduler is the part of the JVM that decides which thread should run.There is no guarantee that which runnable thread will be chosen by the thread scheduler to run . Only one thread at a time can run in a single process.The thread scheduler mainly uses pre-emptive or time slicing scheduling to schedule the threads.

Difference between preemptive scheduling and time slicing :
---------------------------------------------------------
Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence.
Under time slicing, a task executes for a predefined slice of time and then re-enters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors. 

Difference between Thread vs Runnable interface :-->
------------------------------------------------
Thread in Java seems easy in comparison of Runnable because you just deal with one class java.lang.Thread while in case of using Runnable to implement Thread you need to deal with both Thread and Runnable two classes.
though you have another choice as "Callable" for implementing thread which we will discuss later.
/
Thread vs Runnable in Java

1) Java doesn't support multiple inheritance, which means you can only extend one class in Java so once you extended Thread class you lost your chance and can not extend or inherit another class in Java.

2) In Object oriented programming extending a class generally means adding new functionality, modifying or improving behaviour. If we are not making any modification on Thread than use Runnable interface instead.

3) Runnable interface represent a task which can be executed by either plain Thread or Executors or any other means. so logical separation of Task as Runnable than Thread is good design decision.

4) Separating task as Runnable means we can reuse the task and also has liberty to execute it from different means. since you can not restart a Thread once it completes. again Runnable vs Thread for task, Runnable is winner.

5) Java designer recognizes this and that's why Executors accept Runnable as Task and they have worker thread which executes those task.

6) Inheriting Thread`s all methods is additional overhead just for representing a Task which can be done easily with Runnable.
   I personally use Runnable over Thread for this scenario and recommends to use Runnable or Callable interface based on your requirement.

-----------------------------------------

Callable Interface :
-------------------
The Callable provides additional functionality over Runnable in terms of returning result of computation and able to throw Exception.. Since return type of run() method is void it can not return anything which is sometime necessary. 
On the other hand Callable interface defines call() method which has return type as Future which can be used to return result of computation from Thread in Java.
Java Callable interface use Generic to define the return type of Object. Executors class provide useful methods to execute Java Callable in a thread pool. Since callable tasks run in parallel, we have to wait for the returned Object.

Future Example:
-------------------------
Java Callable tasks return java.util.concurrent.Future object. Using Java Future object, we can find out the status of the Callable task and get the returned Object.
It(Future) provides get() method that can wait for the Callable to finish and then return the result.

Java Future provides cancel() method to cancel the associated Callable task. There is an overloaded version of get() method where we can specify the time to wait for the result, 
itís useful to avoid current thread getting blocked for longer time. There are isDone() and isaCncelled() methods to find out the current status of associated Callable task.

Example :com.thread.callablefuture.MyCallable

Once we execute the above program, you will notice the delay in output because java Future get() method waits for the java callable task to complete. 
Also notice that there are only 10 threads executing these tasks.

#About Java Callable Future interfaces that we can use to get the concurrent processing benefits of threads as well as they are capable of returning value to the calling program
Callable is also a single abstract method type (SAM type), so it can be used along with lambda expression on Java 8. Both Callable and Future are parametric type and can be used to wrap classes like Integer, String or anything else

Once you started using thread pool, Callable and Future, you don't need to wait for task to be completed, you can move on with other task and comeback to check whether task is completed or not. If task is finished then just get the result by calling get() method, but remember its a blocking call, so it will block if task is not finished.

Example : com.thread.callablefuture.HelloWorldApp
When you run this program, you will see that first 4 lines will be printed immediately because submit() is a non blocking method, it just takes a task and returns a Future object, it doesn't wait until task is completed. That's why you see that all three tasks to calculate factorials are submitted immediately, but they are not done yet. When our code calls get() on first Future object its blocked until the calculation is done, that's why you will see the fifth line printing after sometime. For next two lines also same story because when you call get() method it will block until result is available. BTW, you don't need to block, you can even use isDone() method to check if calculation is completed or not before calling get method.

Important points about Callable and Future:
-----------------------------------------
1) Callable is a SAM type interface, so it can be used in lambda expression.

2) Callable has just one method call() which holds all the code needs to executed asynchronously.

3) In Runnable interface, there was no way to return the result of computation or throw checked exception but with Callable you can both return a value and can throw checked exception.

4) You can use get() method of Future to retrieve result once computation is done. You can check if computation is finished or not by using isDone() method.

5) You can cancel the computation by using Future.cancel() method.

6) get() is a blocking call and it blocks until computation is completed.

There is an overloaded method also to wait for only specified amount of time and we are using it for futureTask2. Also notice the use of isDone() method to make sure program gets terminated once all the tasks are executed.

		
		
Quest : Why thread communication methods wait(), notify() and notifyAll() are in Object class?
Ans : 		
		
		
		
		
											ExecutorService
									   --------------------------
		
ExecutorService : The java.util.concurrent.ExecutorService interface represents an asynchronous execution mechanism which is capable of executing tasks in the background.
---------------   Once the thread has delegated the task to the ExecutorService, the thread continues its own execution independent of the execution of that task. 
Example: 

ExecutorService executorService = Executors.newFixedThreadPool(10);

executorService.execute(new Runnable() {
    public void run() {
        System.out.println("Asynchronous task");
    }
});

//or -- Java8 style --

executorService.execute(() -> {   System.out.println("Asynchronous task");     });

executorService.shutdown();

ExecutorService Implementations:  ThreadPoolExecutor , ScheduledThreadPoolExecutor
-------------------------------

Creating an ExecutorService :
----------------------------
ExecutorService executorService1 = Executors.newSingleThreadExecutor(); 
ExecutorService executorService2 = Executors.newFixedThreadPool(10);
ExecutorService executorService3 = Executors.newScheduledThreadPool(10);

ExecutorService Usage : There are a few different ways to delegate tasks for execution to an ExecutorService: 
-----------------------    
execute(Runnable)
submit(Runnable)
submit(Callable)
invokeAny(...)
invokeAll(...)

execute(Runnable) : The execute(Runnable) method takes a java.lang.Runnable object, and executes it asynchronously. 
-------------------
Example : 
ExecutorService executorService = Executors.newSingleThreadExecutor();

executorService.execute(   ()->{System.out.println("Asynchronous task"); }  );
executorService.shutdown();


Note : There is no way of obtaining the result of the executed Runnable, if necessary. You will have to use a Callable for that (explained in the following sections). 

submit(Runnable): The submit(Runnable) method also takes a Runnable implementation, but returns a Future object. This Future object can be used to check if the Runnable as finished executing. 
----------------
Example :
Future future =  executorService.execute(   ()->{System.out.println("Asynchronous task"); }  );

future.get();  //returns null if the task has finished correctly.

submit(Callable): The submit(Callable) method is similar to the submit(Runnable) method except for the type of parameter it takes. The Callable instance is very similar to a Runnable except that its call() method can return a result. The Runnable.run() method cannot return a result. 
----------------- The Callable's result can be obtained via the Future object returned by the submit(Callable) method. 
Example :
Future future = executorService.submit(new Callable(){
    public Object call() throws Exception {
        System.out.println("Asynchronous Callable");
        return "Callable Result";
    }
});
System.out.println("future.get() = " + future.get());

Output :
Asynchronous Callable
future.get() = Callable Result

invokeAny() :  The invokeAny() method takes a collection of Callable objects, or subinterfaces of Callable. Invoking this method does not return a Future, but returns the result of one of the Callable objects. You have no guarantee about which of the Callable's results you get. Just one of the ones that finish.
------------   If one of the tasks complete (or throws an exception), the rest of the Callable's are cancelled. 
Example : com.thread.executorservice.methods.InvokeAnyMethod

ExecutorService executorService = Executors.newSingleThreadExecutor();

Set<Callable<String>> callablesSet = new HashSet<Callable<String>>();

callablesSet.add(new Callable<String>() {
    public String call() throws Exception {
        return "Task 1";
    }
});
callablesSet.add(new Callable<String>() {
    public String call() throws Exception {
        return "Task 2";
    }
});
callablesSet.add(new Callable<String>() {
    public String call() throws Exception {
        return "Task 3";
    }
});

String result = executorService.invokeAny(callablesSet);
System.out.println("result = " + result);
executorService.shutdown();

Output :
This code example will print out the object returned by one of the Callable's in the given collection. I have tried running it a few times, and the result changes. Sometimes it is "Task 2", sometimes "Task 3" etc. 


invokeAll() : The invokeAll() method invokes all of the Callable objects you pass to it in the collection passed as parameter. The invokeAll() returns a list of Future objects via which you can obtain the results of the executions of each Callable.  
-----------
Note : Keep in mind that a task might finish due to an exception, so it may not have "succeeded". There is no way on a Future to tell the difference. 
Example : com.thread.executorservice.methods.InvokeAllMethod


ExecutorService Shutdown() : It will just tell the executor service that it can't accept new tasks, but the already submitted tasks continue to run.
------------------------
When you are done using the ExecutorService you should shut it down, so the threads do not keep running.
For instance, if your application is started via a main() method and your main thread exits your application, the application will keep running if you have an active ExexutorService in your application. The active threads inside this ExecutorService prevents the JVM from shutting down.
To terminate the threads inside the ExecutorService you call its shutdown() method. The ExecutorService will not shut down immediately, but it will no longer accept new tasks, and once all threads have finished current tasks, the ExecutorService shuts down. All tasks submitted to the ExecutorService before shutdown() is called, are executed. 
This is precisely the reason why sometimes the shutdown() may not be enough as shutdown() just ensures that no new tasks are accepted. The submitted tasks and currently running tasks are allowed to continue. 

shutdownNow() : If you want to shut down the ExecutorService immediately, you can call the shutdownNow() method. This will attempt to stop all executing tasks right away, and skips all submitted but non-processed tasks. 
------------

awaitTermination() : On awaitTermination, you could specify the timeout period until which the main thread should wait for the pool threads to complete its tasks.
------------------
As per the documentation, method blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first.
awaitTermination is invoked after a shutdown request
Example : com.thread.executorservice.methods.AwaitTerminationMethod


ThreadPoolExecutor :
--------------------
Java thread pool manages the pool of worker threads, it contains a queue that keeps tasks waiting to get executed. We can use ThreadPoolExecutor to create thread pool in java.
The java.util.concurrent.ThreadPoolExecutor is an implementation of the ExecutorService interface. The ThreadPoolExecutor executes the given task (Callable or Runnable) using one of its internally pooled threads. 
java.util.concurrent.Executors provides utility methods for the implementation of java.util.concurrent.Executor interface to create the thread pool in java.

Example :com.thread.threadpool.SimpleThreadPool
In above program, we are creating fixed size thread pool of 5 worker threads. Then we are submitting 10 jobs to this pool, since the pool size is 5, 
it will start working on 5 jobs and other jobs will be in wait state, as soon as one of the job is finished, another job from the wait queue will be picked up by worker thread and get's executed.

ScheduledExecutorService : The java.util.concurrent.ScheduledExecutorService is an ExecutorService which can schedule tasks to run after a delay, or 
-------------------------  to execute repeatedly with a fixed interval of time in between each execution. Tasks are executed asynchronously by a worker thread, 
						   and not by the thread handing the task to the ScheduledExecutorService.

Example : com.thread.threadpool.ScheduledExecutorServiceExample
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5);


ScheduledExecutorService Usage :  Once you have created a ScheduledExecutorService you use it by calling one of its methods: 
-------------------------------
schedule (Callable task, long delay, TimeUnit timeunit)
schedule (Runnable task, long delay, TimeUnit timeunit)
scheduleAtFixedRate (Runnable, long initialDelay, long period, TimeUnit timeunit)
scheduleWithFixedDelay (Runnable, long initialDelay, long period, TimeUnit timeunit)

schedule (Callable task, long delay, TimeUnit timeunit) : This method schedules the given Callable for execution after the given delay.
---------------------------------------------------------
The method returns a ScheduledFuture which you can use to either cancel the task before it has started executing, or obtain the result once it is executed. 
Example : com.thread.executorservice.methods.ScheduleCallableMethod


schedule (Runnable task, long delay, TimeUnit timeunit) : This method works like the method version taking a Callable as parameter, except a Runnable cannot return a value, so the ScheduledFuture.get() method returns null when the task is finished.  
-------------------------------------------------------
Example : com.thread.executorservice.methods.ScheduleRunnableMethod




scheduleAtFixedRate (Runnable, long initialDelay, long period, TimeUnit timeunit) :  Executes a periodic task after an initial delay, then repeat after every given period. If any execution of this task takes longer than its period, then subsequent executions may start late, but will not concurrently execute.
-----------------------------------------------------------------------------------
Example : com.thread.executorservices.ScheduledExecutorServiceScheduleAtFixedRate
//I  have a cup of coffee, which takes 10 minutes. Suppose that starts at midnight, I'd have
00:00: Start making coffee
00:10: Finish making coffee
01:00: Start making coffee
01:10: Finish making coffee
02:00: Start making coffee
02:10: Finish making coffee

scheduleWithFixedDelay (Runnable, long initialDelay, long period, TimeUnit timeunit) : Executes a periodic task after an initial delay, then repeat after every given delay between the termination of one execution and the commencement of the next.
-------------------------------------------------------------------------------------
Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently with the given delay between the termination of one execution and the commencement of the next.
Example : com.thread.executorservices.ScheduledExecutorServiceScheduleWithFixedDelay

If I schedule with a fixed delay of one hour, I'd have: scheduleWithFixedDelay() :
00:00: Start making coffee
00:10: Finish making coffee
01:10: Start making coffee
01:20: Finish making coffee
02:20: Start making coffee
02:30: Finish making coffee

-----------------------------------------------------------------------------------
Thread wait, notify and notifyAll :-->
----------------------------------
http://www.journaldev.com/1037/java-thread-wait-notify-and-notifyall-example
* The Object class in java contains three final methods that allows threads to communicate about the lock status of a resource. These methods are wait(), notify() and notifyAll().
* The current thread which invokes these methods on any object should have the object monitor else it throws java.lang.IllegalMonitorStateException exception. 

wait() :-->
-------
Object`s wait() methods has three variance, one wait() method put current Thread in wait state and waits indefinitely for any other thread to call notify or notifyAll method on the same object to wake up the waiting thread. Other two variances puts the current thread in wait for specific amount of time before they wake up.

wait() method puts a thread on wait by checking some condition like in Producer Consumer problem, producer thread should wait if Queue is full or Consumer thread should wait if Queue is empty. notify() method is used to wake up waiting thread by communicating that waiting condition is over now; for example once producer thread puts an item on empty queue then it (notify() method) can notify Consumer thread that Queue is not empty any more.

notify:-->
--------
notify method wakes up only one thread waiting on the object and that thread starts execution. So if there are multiple threads waiting on an object, this method will wake up only one of them. The choice of the thread to wake depends on the OS implementation of thread management.

notifyAll:-->
----------
notifyAll method wakes up all the threads waiting on the object, although which one will process first depends on the OS implementation.

*These methods can be used to implement producer consumer problem where consumer threads are waiting for an objects in Queue and producer threads put object in queue and notify the waiting threads.

Example is present in the below package for wait,notify and notifyAll methods.
com.threads.waitnotifynotifyall or com.threads.producerconsumer.waitnotify

----------------------

Sleep method in Java :-->
------------------------------------
http://www.journaldev.com/1020/java-thread-sleep-example

java.lang.Thread sleep() method can be used to pause the execution of current thread for specified time in milliseconds. The argument value for milliseconds canít be negative, else it throws IllegalArgumentException.

You can put a current Thread on sleep, where it does not do anything and relinquish/discard the CPU for specified duration. When a Thread is in Sleep then it can be either wake up normally after sleep duration elapsed or it can be woken up abnormally by interrupting it.

POC:-->
public class ThreadSleep {
 
    public static void main(String[] args) throws InterruptedException {
        long start = System.currentTimeMillis();
        Thread.sleep(2000);
        System.out.println("Sleep time in ms = "+(System.currentTimeMillis()-start));
    }
}

Thread Sleep important points-->
-----------------------------
1. It always pause the current thread execution.
2. The actual time thread sleeps before waking up and start execution depends on system timers and schedulers. For a quiet system, the actual time for sleep is near to the specified sleep time but for a busy system it will be little bit more.
3. sleep doesnít lose any monitors or locks that current thread has acquired.
4. Any other thread can interrupt the current thread in sleep, in that case InterruptedException is thrown.

How Thread Sleep Works:-->
-----------------------
Thread.sleep() interacts with the thread scheduler to put the current thread in wait state for specified period of time. Once the wait time is over, thread state is changed to runnable state and wait for the CPU for further execution. So the actual time that current thread sleep depends on the thread scheduler that is part of operating system.

Example : SleepTest.java

Difference between wait and sleep in Java :-->
-------------------------------------------
1) First and most important difference between is that wait method must be called from synchronized context i.e. from synchronized method or block in Java. If you call wait method without synchronization, it will throw IllegalMonitorStateException . On the other hand there is no requirement of synchronization for calling sleep method,you can call it normally.

2) wait is called on Object while sleep is called on Thread. 

3) waiting thread can be awake by calling notify and notifyAll while sleeping thread can not be awaken by calling notify method.

4) wait is normally done on condition and Thread wait until a condition is true while sleep is just to put your thread on sleep and it can be either wake up normally after sleep duration elapsed or it can be woken up abnormally by interrupting it..

5) wait method needs to be called from a loop in order to deal with false alarm i.e. waking even though waiting condition still holds true, while there is no such thing for sleep method in Java. its better not to call Sleep method from loop.

6) Wait releases lock and goes back to Runnable state once waiting state over but Sleep doesn`t release lock and may start running once its wakes up.
here is code snippet for calling wait and sleep method in Java

wait() :-->
synchronized(monitor){
while or if (condition == true)
{
   monitor.wait()  //releases monitor lock
} 
}

sleep():-->
Thread.sleep(100); //puts current thread on Sleep

6)One more difference between wait and sleep method which is not as significant as previous ones is that wait() is a non static method while sleep() is static method .

Where to use wait and sleep method in Java:-->
---------------------------------------------
By reading properties and behaviour of wait and sleep method it's clear that wait() method should be used in conjunction with notify() or notifyAll() method and intended for communication between two threads in Java while Thread.sleep() method is a utility method to introduce short pauses during program or thread execution. 

------------------------------------------------
 
 
Thread class Join method in Java :--> 
----------------------------------
http://fastlearning.in/java/java_joining_threads.php
http://www.journaldev.com/1024/java-thread-join-example-with-explanation

join method can be used to pause the current thread execution until unless the specified thread is dead. There are three overloaded join functions.

public final synchronized void join(): --> This method puts the current thread on wait until the thread on which itís called is completed/dead. If the thread is interrupted,
-------------------------     it throws InterruptedException.

public final synchronized void join(long millis): -->This method is used to wait for the thread on which itís called to be dead or wait for specified
----------------------------------------------	     milliseconds. Since thread execution depends on OS implementation, it doesnít guarantee that the current thread will wait only for given time.

public final synchronized void join(long millis, int nanos):--> This method is used to wait for thread to die for given milliseconds plus nanoseconds. 
-----------------------------------------------------------     

Example1:--> The goal of the program is to make sure main is the last thread to finish and third thread starts only when first one is dead.
com./test.joinmethod.ThreadJoinExample

Example2 :--> 
com./test.joinmethod.Join

public class Join {
 
    public static void main(String args[]) throws InterruptedException{
     
        System.out.println(Thread.currentThread().getName() + " is Started");
     
        Thread exampleThread = new Thread(){
            public void run(){
                try {
                    System.out.println(Thread.currentThread().getName() + " is Started..!!");
                    Thread.sleep(2000);
                    System.out.println(Thread.currentThread().getName() + " is Completed..!!");
                } catch (InterruptedException ex) {
                    Logger.getLogger(Join.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        };
    
		exampleThread.start();
        exampleThread.join();
     
        System.out.println(Thread.currentThread().getName() + " is Completed");
    }
 
}

Output:
main is Started
Thread-0 is Started
Thread-0 is Completed
main is Completed

If you look at above example, first main thread is started and than it creates another thread, whose name is "Thread-0" and started it. Since Thread-0 sleep for 2 seconds, it require at least 2 seconds to complete and in between main thread called join method on Thread-0 object. Because of join method, now main thread will wait until Thread-0 completes its operation or You can say main thread will join Thread-0. If you look on output, it confirms this theory.

Important point on Thread.join method :-->
-----------------------------------------
1. Join is a final method in java.lang.Thread class and you cannot override it.
2) Join method throw IntrupptedException if another thread interrupted waiting thread as a result of join() call.

3) Join is also an overloaded method in Java, three version of join() available, check javadoc for details.
http://javarevisited.blogspot.in/2013/02/how-to-join-multiple-threads-in-java-example-tutorial.html

------------------------------------------------

ThreadLocal in Java :-->
--------------------
http://javarevisited.blogspot.in/2012/05/how-to-use-threadlocal-in-java-benefits.html
http://veerasundar.com/blog/2010/11/java-thread-local-how-to-use-and-code-sample/
Java ThreadLocal is used to create thread`s local variable.We know that all thread of an Object share it`s variable.
ThreadLocal in Java is a different way to achieve thread-safety, it doesn't address synchronization requirement, instead it eliminates sharing by providing explicitly copy of Object to each thread. Since Object is no more shared there is no requirement of Synchronization which can improve scalability and performance of application.

# ThreadLocal can be used to maintain the each Thread state, As Thread has its own copy on this ThreadLocal variable.
# ThreadLocal provides set() and get() method to set/get the value and remove() to remove the value from formatter.

Example : com./test.threadlocal.ThreadLocalDemo and com./test.threadlocal1.ThreadLocalExample

When to use ThreadLocal in Java:-->
-------------------------------
1) ThreadLocal is fantastic to implement Per Thread Singleton classes or per thread context information like transaction id.

2) You can wrap any non Thread Safe object in ThreadLocal and suddenly its uses becomes Thread-safe, as its only being used by Thread Safe. One of the classic example of ThreadLocal is sharing SimpleDateForamt. Since SimpleDateFormat is not thread safe, having a global formatter may not work but having per Thread formatter will certainly work.

3) ThreadLocal provides another way to extend Thread. If you want to preserve or carry information from one method call to another you can carry it by using ThreadLocal. This can provide immense flexibility as you don't need to modify any method.

---------------------------------------


-------------------------------------------------

Java Atomic Operations :-->
------------------------------
Atomic operations are performed in a single unit of task without interference from other operations. Atomic operations are necessity in multi-threaded environment to avoid data inconsistency.

Letís create a simple multi-threaded program where every thread increments the shared count variable 4 times. So if there are two threads, after they finish count value should be 8.

Example : com.thread.automic.JavaAtomicWithoutAtomicInteger

If you run above program, you will notice that count value varies between 5 to 8. The reason is because count++ is not an atomic operation. So by the time one threads read itís value and increment it by one, other thread has read the older value leading to wrong result. 

To solve this issue, we will have to make sure that increment operation on count is atomic, we can do that using Synchronization but Java 5 java.util.concurrent.atomic provides wrapper classes for int and long that can be used to achieve this atomically without usage of Synchronization.

Here is the updated program that will always output count value as 8 because AtomicInteger incrementAndGet() atomically increments the current value by one.

Example : com.thread.automic.JavaAtomic

Benefits of using Atomic Concurrency classes is that we donít need to worry about synchronization at each and every place we are dealing with integers and itís assumed to be more efficient then synchronization which involves locking resources.

-------------------------------------------------------
 
How Synchronization works in Java ? Example of synchronized block :-->
----------------------------------------------------------------- 
http://www.journaldev.com/1061/java-synchronization-and-thread-safety-tutorial-with-examples

JVM guarantees that Java synchronized code will only be executed by one thread at a time.

Synchronization in Java will only be needed if shared object is mutable. if your shared object is read-only or immutable object you don't need synchronization despite running multiple threads. Same is true with what threads are doing with object if all the threads are only reading value then you don't require synchronization in java. 

In Summary Java Synchronized Keyword provides following functionality essential for concurrent programming :

1) synchronized keyword provides locking which ensures mutual exclusive access of shared resource and prevent data race condition/situation.
2) synchronized keyword also prevent reordering of code statement by compiler which can cause subtle concurrent issue if we don't use synchronized or volatile keyword.
3) synchronized keyword involve locking and unlocking. before entering into synchronized method or block thread needs to acquire the lock, at this point it reads data from main memory than cache it and when it release the lock it flushes write operation into main memory which eliminates memory inconsistency errors.

Synchronized keyword in Java:-->
----------------------------
Any code written in synchronized block in java will be mutual exclusive and can only be executed by one thread at a time. You can have both static synchronized method and/or non static synchronized method and synchronized blocks in java but we can not have synchronized variable in java. Using synchronized keyword with variable is illegal and will result in compilation error. 

Instead of java synchronized variable you can have java volatile variable, which will instruct JVM threads to read value of volatile variable from main memory and donít cache it locally. Block synchronization in java is preferred over method synchronization in java because by using block synchronization you only need to lock the critical section of code instead of whole method. Since java synchronization comes with cost of performance so we should synchronize only part of code which absolutely needs to be synchronized.

Example of synchronized method in Java:-->
--------------------------------------
Using synchronized keyword with method is easy just apply synchronized keyword in front of method. What we need to take care is that static synchronized method locked on class and non static synchronized method locks on current object (this). So itís possible that both static and non static java synchronized method running in parallel.This is the common mistake a naive developer do while writing java synchronized code.

public class Counter{
private static int count = 0;

public static synchronized int getCount(){
  return count;
}

public synchoronized setCount(int count){
   this.count = count;
}

}

In this example of java synchronization code is not properly synchronized because both getCount() and setCount() are not getting locked on same object and can run in parallel which results in getting incorrect count. Here getCount() will lock on Counter class while setCount() will lock on current object (this). To make this code properly synchronized in java you need to either make both method static or non static or use java synchronized block instead of java synchronized method.

Using synchronized block in java is also similar to using synchronized keyword in methods. Only important thing to note here is that if object is used to lock synchronized block of code and Singleton.class in below example is null then java synchronized block will throw a NullPointerException.

Example of synchronized block in Java

public class Singleton{
private static Singleton _instance;

public static Singleton getInstance(){

   if(_instance == null){
            synchronized(Singleton.class){
              if(_instance == null)
              _instance = new Singleton();
            }

   }
   return _instance;

}

This is a classic example of double checked locking in Singleton. In this example of java synchronized code we have made only critical section (part of code which is creating instance of Singleton) synchronized and saved some performance because if you make whole method synchronized every call of this method will be blocked while you only need to create instance on first call.

Important points of synchronized keyword in Java:
--------------------------------------------------
1. Synchronized keyword in Java is used to provide mutual exclusive access of a shared resource with multiple threads in Java. Synchronization in java guarantees that no two threads can execute a synchronized method which requires same lock simultaneously or concurrently.

2. You can use java synchronized keyword only on method or block.

3. Whenever a thread enters into java synchronized method or block it acquires a lock and whenever it leaves java synchronized method or block it releases the lock. Lock is released even if thread leaves synchronized method after completion or due to any Error or Exception.

4. Java Thread acquires an object level lock when it enters into an instance synchronized java method and acquires a class level lock when it enters into static synchronized java method.

5. java synchronized keyword is re-entrant in nature it means if a java synchronized method calls another synchronized method which requires same lock then current thread which is holding lock can enter into that method without acquiring lock.

6. Java Synchronization will throw NullPointerException if object used in java synchronized block is null e.g. synchronized (myInstance){} will throws NullPointerException if myInstance is null.

7. One Major disadvantage of java synchronized keyword is that it doesn't allow concurrent read which you can implement using java.util.concurrent.locks.ReentrantLock.

8. One limitation of java synchronized keyword is that it can only be used to control access of shared object within the same JVM. If you have more than one JVM and need to synchronized access to a shared file system or database, the java synchronized keyword is not at all sufficient. You need to implement a kind of global lock for that.

9. Java synchronized keyword incurs performance cost. Synchronized method in Java is very slow and can degrade performance. So use synchronization in java when it absolutely requires and consider using java synchronized block for synchronizing critical section only.

10. Java synchronized block is better than java synchronized method in java because by using synchronized block you can lock only critical section of code and avoid locking whole method which can possibly degrade performance. A good example of java synchronization around this concept is getInstance() method of Singleton class.
    
11. Its possible that both static synchronized and non static synchronized method can run simultaneously or concurrently because they lock on different object.

12. From java 5 after change in Java memory model reads and writes are atomic for all variables declared using volatile keyword (including long and double variable ) and simple atomic variable access is more efficient instead of accessing these variables via synchronized java code. But it requires more care and attention from the programmer to avoid memory consistency errors.

13. Java synchronized code could result in deadlock or starvation while accessing by multiple thread if synchronization is not implemented correctly. 

14. According to the Java language specification you can not use java synchronized keyword with constructor itís illegal and result in compilation error. So you can  not synchronized constructor in Java which seems logical because other threads cannot see the object being created until the thread creating it has finished it.

15. You cannot apply java synchronized keyword with variables and can not use java volatile keyword with method.

16. Java.util.concurrent.locks extends capability provided by java synchronized keyword for writing more sophisticated programs since they offer more capabilities e.g. Reentrancy and interruptible locks.

17. java synchronized keyword also synchronizes memory. In fact java synchronized synchronizes the whole of thread memory with main memory.

18. Important method related to synchronization in Java are wait(), notify() and notifyAll() which is defined in Object class.

19. Do not synchronize on non final field on synchronized block in Java. because reference of non final field may change any time and then different thread might synchronizing on different objects i.e. no synchronization at all. example of synchronizing on non final field :

private String lock = new String("lock");
synchronized(lock){
System.out.println("locking on :"  + lock);
}
if you write synchronized code like above in java you may get warning "Synchronization on non-final field"  in IDE like Netbeans and InteliJ

20. Its not recommended to use String object as lock in java synchronized block because string is immutable object and literal string an interned string gets
    stored in String pool. so by any chance if any other part of code or any third party library used same String as their lock then they both will be locked on same object despite being completely unrelated which could result in unexpected behavior and bad performance. instead of String object its advised to use
    new Object() for Synchronization in Java on synchronized block.

private static final String LOCK = "lock";   //not recommended
private static final Object OBJ_LOCK = new Object(); //better

public void process() {
   synchronized(OBJ_LOCK) {
      ........
   }
}

21. From Java library Calendar and SimpleDateFormat classes are not thread-safe and requires external synchronization in Java to be used in multi-threaded
    environment.  


Que :  How to write Thread-Safe Code in Java ?
Ans : Here is an example of non thread-safe code, look at the code and find out why this code is not thread safe ?

/*
 * Non Thread-Safe Class in Java
 */
public class Counter {
  
    private int count;
  
    /*
     * This method is not thread-safe because ++ is not an atomic operation
     */
    public int getCount(){
        return count++;
    }
}

Above example is not thread-safe because ++ (increment operator) is not an atomic operation and can be broken down into read, update and write operation. if multiple thread call getCount() approximately same time each of these three operation may coincide or overlap with each other for example while thread 1 is updating value, thread 2 reads and still gets old value, which eventually let thread 2 override thread 1 increment and one count is lost because multiple thread called it 
concurrently.

There are multiple ways to make this code thread safe in Java:

1) Use synchronized keyword in Java and lock the getCount() method so that only one thread can execute it at a time which removes possibility of coinciding or
   interleaving.

2) use Atomic Integer, which makes this ++ operation atomic and since atomic operations are thread-safe and saves cost of external synchronization.


here is a thread-safe version of Counter class in Java:

/*
 * Thread-Safe Example in Java
 */
public class Counter {
  
    private int count;
    AtomicInteger atomicCount = new AtomicInteger( 0 );

  
    /*
     * This method thread-safe now because of locking and synchornization
     */
    public synchronized int getCount(){
        return count++;
    }
  
    /*
     * This method is thread-safe because count is incremented atomically
     */
    public int getCountAtomically(){
        return atomicCount.incrementAndGet();
    }
}

Important points about Thread-Safety in Java

1) Immutable objects are by default thread-safe because their state can not be modified once created.As String is immutable in Java,its inherently thread-safe.
2) Read only or final variables in Java are also thread-safe in Java.
3) Locking is one way of achieving thread-safety in Java.
4) Static variables if not synchronized properly becomes major cause of thread-safety issues.
5) Example of thread-safe class in Java: Vector, HashTable, ConcurrentHashMap, String etc.
6) Atomic operations in Java are thread-safe e.g. reading a 32 bit int from memory because its an atomic operation it can't interleave with other thread.
7) local variables are also thread-safe because each thread has there own copy and using local variables is good way to writing thread-safe code in Java.
8) In order to avoid thread-safety issue minimize sharing of objects between multiple thread.
9) Volatile keyword in Java can also be used to instruct thread not to cache variables and read from main memory and can also instruct JVM not to reorder or   
    optimize code from threading perspective.

----------------------------------------------------------------------------------------------------
Java Daemon Thread:-->
---------------------
http://www.journaldev.com/1072/java-daemon-thread-example
When we create a Thread in java, by default itís a user thread and if itís running then JVM will not terminate the program. When a thread is marked as daemon thread, JVM doesnít wait to finish its execution and as soon as all the user threads are finished, it terminates the program as well as all the associated daemon threads.

Thread.setDaemon(true) can be used to create a daemon thread in java. Letís see a small example of java daemon thread:-->
Example : com.threads.basics.JavaDaemonThread

When we execute this program, JVM first creates  user thread within main() function and then a daemon thread. When main function is finished, the program terminates and daemon thread is also shut down by JVM.

Here is the output of the above program.
Processing daemon thread
Processing daemon thread
Processing daemon thread
Processing daemon thread
Processing daemon thread
Processing daemon thread
Finishing program

If we donít set the thread to be run as daemon thread, the program will never terminate even after main thread is finished itís execution. Try commenting the statement to set thread as daemon thread and run the program.

Usually we create a daemon thread for functionalities that are not critical to system, for example logging thread or monitoring thread to capture the system resource details and their state.

-------


ReentrantLock :==>
----------------
ReentrantLock is a concrete implementation of Lock interface provided in Java concurrency package from Java 1.5 onwards.  As per Javadoc, ReentrantLock is mutual 
exclusive lock, similar to implicit locking provided by synchronized keyword in Java, with extended feature like fairness, which can be used to provide lock to 
longest waiting thread.
Lock is acquired by lock() method and held by Thread until a call to unlock() method. Fairness  parameter is provided while creating instance of ReentrantLock in constructor.
ReentrantLock lock = new ReentrantLock(true);

Difference between ReentrantLock and synchronized keyword :
-----------------------------------------------------------
1. Fairness : synchronized keyword doesn't support fairness. Any thread can acquire lock once released, no preference can be specified, on the other hand you can make ReentrantLock fair by specifying fairness property, while creating instance of ReentrantLock. Fairness property provides lock to longest waiting thread, in case of contention.
2. tryLock() :  ReentrantLock provides convenient tryLock() method, which acquires lock only if its available or not held by any other thread. This reduce blocking of thread waiting for lock.
3. ability to interrupt : It has ability to interrupt Thread while waiting for Lock. In case of synchronized keyword, a thread can be blocked waiting for lock, for an indefinite period of time and there was no way to control that.
                          ReentrantLock provides a method called lockInterruptibly(), which can be used to interrupt thread when it is waiting for lock.
						  Similarly tryLock() with timeout can be used to timeout if lock is not available in certain time period.
4) ReentrantLock also provides convenient method to get List of all threads waiting for lock.


ReentrantLock Methods

    lock(): Call to the lock() method increments the hold count by 1 and gives the lock to the thread if the shared resource is initially free.
    unlock(): Call to the unlock() method decrements the hold count by 1. When this count reaches zero, the resource is released.
    tryLock(): If the resource is not held by any other thread, then call to tryLock() returns true and the hold count is incremented by one. If the resource is not free then the method returns false and the thread is not blocked but it exits.
    tryLock(long timeout, TimeUnit unit): As per the method, the thread waits for a certain time period as defined by arguments of the method to acquire the lock on the resource before exiting.
    lockInterruptibly(): This method acquires the lock if the resource is free while allowing for the thread to be interrupted by some other thread while acquiring the resource. It means that if the current thread is waiting for lock but some other thread requests the lock, then the current thread will be interrupted and return immediately without acquiring lock.
    getHoldCount(): This method returns the count of the number of locks held on the resource.
    isHeldByCurrentThread(): This method returns true if the lock on the resource is held by the current thread.

	
----------------------------------------------------------------------------

Semaphore :==>
--------------
http://javarevisited.blogspot.com/2012/05/counting-semaphore-example-in-java-5.html#ixzz3Y0DQJQys
Semaphore is a technique used to control the access to common resource for competing multiple processes. Semaphore maintains a counter which keeps track of the number of resources available. When a process requests access to resource, semaphore checks the variable count and if it is less than total count then grants access and subsequently reduces the available count.

Semaphore is just a gatekeeper guarding the resources. If resources available then grants access and otherwise asks the processes to wait.
or
In order to access a shared resource, Current Thread must acquire a permit. If permit is already taken by other thread than it can wait until a permit is available due to release of permit from different thread.
This concurrency utility can be very useful to implement producer consumer design pattern or implement bounded pool or resources like Thread Pool, DB Connection pool etc. 
java.util.concurrent.Semaphore class represents a Counting semaphore which is initialized with number of permits. Semaphore provides two main method acquire() and release() for getting permits and releasing permits. acquire() method blocks until permit is not available. Semaphore provides both blocking method as well as unblocking method to acquire permits. 
This concurrency utility can be very useful to implement producer consumer design pattern or implement bounded pool or resources like Thread Pool, DB Connection pool etc. 
A Counting semaphore with one permit is known as binary semaphore because it has only two state permit available or permit unavailable. Binary semaphore can be used to implement mutual exclusion or critical section where only one thread is allowed to execute. Other Thread will wait on acquire() until Thread inside critical section release permit by calling release() on semaphore.

Some Scenario where Semaphore can be used:-->
-------------------------------------------- 
1) To implement better Database connection pool which will block if no more connection is available instead of failing and it handover Connection as soon as its available.

2) To put a bound on collection classes. by using semaphore you can implement bounded collection whose bound is specified by counting semaphore.

Example : com./test.semaphore.* and com.kp.SFDemo , com.kp.SemaphoreTest 

---------------------------------------

CyclicBarrier in Java:-->
-------------------------
http://javarevisited.blogspot.in/2012/07/cyclicbarrier-example-java-5-concurrency-tutorial.html
CyclicBarrier is a natural requirement for concurrent program because it can be used to perform final part of task once individual tasks are completed. All threads which wait for each other to reach barrier are called parties, CyclicBarrier is initialized with number of parties to wait and threads wait for each other by calling CyclicBarrier.await() method which is a blocking method in Java and blocks until all Thread or parties call await(). In general calling await() is shout out that Thread is waiting on barrier. await() is a blocking call but can be timed out or Interrupted by other thread.

#you can reuse CyclicBarrier by calling reset() method which resets Barrier to its initial State.

Difference between CountDownLatch and CyclicBarrier in Java:-->
-----------------------------------------------------------
CountDownLatch can be used to implement multiple threads waiting for each other. If you look at CyclicBarrier it also does the same thing but there is a difference you can not reuse CountDownLatch once count reaches zero while you can reuse CyclicBarrier by calling reset() method which resets Barrier to its initial State. What it implies that CountDownLatch is good for one time event like application start-up time and CyclicBarrier can be used to in case of recurrent event e.g. concurrently calculating solution of big problem etc.

Facts about CountDownLatch:

    Creating an object of CountDownLatch by passing an int to its constructor (the count), is actually number of invited parties (threads) for an event.
    The thread, which is dependent on other threads to start processing, waits on until every other thread has called count down. All threads, which are waiting on await() proceed together once count down reaches to zero.
    countDown() method decrements the count and await() method blocks until count == 0

Example : com.thread.countdownlatch.CountDownLatchExample


When to use CyclicBarrier in Java:-->
-----------------------------------
It can used where a big task is broken down into smaller pieces and to complete the task you need output from individual small task e.g. to count population of India you can have 4 threads which counts population from North, South, East and West and once one complete their task they can wait for others, When last thread completed their task, Main thread or any other thread can add result from each zone and print total population. You can use CyclicBarrier in Java :

1) To implement multi player game which can not begin until all player has joined.
2) Perform lengthy calculation by breaking it into smaller individual tasks, In general to implement Map reduce technique.

Important point of CyclicBarrier in Java:-->
----------------------------------------
1. CyclicBarrier can perform a completion task once all thread reaches to barrier, This can be provided while creating CyclicBarrier.
2. If CyclicBarrier is initialized with 3 parties means 3 thread needs to call await method to break the barrier.
3. Thread will block on await() until all parties reaches to barrier, another thread interrupt or await timed out.
4. If another thread interrupt the thread which is waiting on barrier it will throw BrokenBarrierException as shown below:

java.util.concurrent.BrokenBarrierException
        at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:172)
        at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:327)

5.CyclicBarrier.reset() put Barrier on its initial state, other thread which is waiting or not yet reached barrier will terminate with java.util.concurrent.BrokenBarrierException.

Example : com./test.cyclicbarrier.CyclicBarrierExample or com./test.cyclicbarrier.CyclicBarrierExamplewithMultipeTaks

--------------------------------------------------------------------
Java ClassLoader : ->
--------------------
The Java Classloader is a part of the Java Runtime Environment that dynamically loads Java classes into the Java Virtual Machine.The Java run time system does not need to know about files and file systems because of classloaders.
Each Java class must be loaded by a class loader.[2] Furthermore, Java programs may make use of external libraries .
When the JVM is started, three class loaders are used:
    
    Bootstrap class loader  : The bootstrap class loader loads the core Java libraries[5] located in the <JAVA_HOME>/jre/lib directory. This class loader, which is part of the core JVM, is written in native code. 
    Extensions class loader : The extensions class loader loads the code in the extensions directories (<JAVA_HOME>/jre/lib/ext,[6] or any other directory specified by the java.ext.dirs system property). It is implemented by the sun.misc.Launcher$ExtClassLoader class. 
    System class loader     : The system class loader loads code found on java.class.path, which maps to the CLASSPATH environment variable. user-defined packages and libraries.


How do Class Loaders Work? :-->
--------------------------
Class loaders are part of the Java Runtime Environment. When the JVM requests a class, the class loader tries to locate the class and load the class definition into the runtime using the fully qualified class name.
The java.lang.ClassLoader.loadClass() method is responsible for loading the class definition into runtime. It tries to load the class based on a fully qualified name.
If the class isn’t already loaded, it delegates the request to the parent class loader. This process happens recursively. 

Eventually, if the parent class loader doesn’t find the class, then the child class will call java.net.URLClassLoader.findClass() method to look for classes in the file system itself.
If the last child class loader isn’t able to load the class either, it throws java.lang.NoClassDefFoundError or java.lang.ClassNotFoundException.

Note : 
Class loaders follow the delegation model where on request to find a class or resource, a ClassLoader instance will delegate the search of the class or resource to the parent class loader. 
Only if the bootstrap and then the extension class loader is unsuccessful in loading the class, the system class loader tries to load the class itself.


NoClassDefFoundError :-->
----------------------
NoClassDefFoundError in Java comes when Java Virtual Machine is not able to find a particular class at runtime which was available at compile time. For example, if we have a method call from a class or accessing any static member of a Class and that class is not available during run-time then JVM will throw NoClassDefFoundError.
 In short, NoClassDefFoundError will come if a class was present during compile time but not available in java classpath during runtime. 
 Normally you will see this line in log when you get NoClassDefFoundError:-->   Exception in thread "main" java.lang.NoClassDefFoundError

How to resolve java.lang.NoClassDefFoundError in Java---> The obvious reason of NoClassDefFoundError is that a particular class is not available in Classpath, so we need to add that into Classpath or we need to check why it’s not available in Classpath if we are expecting it to be


ClassNotFoundException:-->
------------------------

1) When we try to load a class by using Class.forName() method and .class file or binary of class is not available in classpath.
2) When Classloader try to load a class by using findSystemClass () method.
3) While using loadClass() method of class ClassLoader in Java.

--------------------------------------------------------------------------------------------------------------




Topic								:: Design Pattern ::
								----------------------------
								
Unbreakable Singleton class : com.dp.singleton.Singleton								
								


1. Singleton Pattern : -->  Singleton is one of the Gangs of Four Design patterns and comes in the Creational Design Pattern category.
-----------------------		
http://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-with-examples

Singleton pattern restricts the multiple instantiation of a class and ensures that only one instance of the class exists in the java virtual machine. The singleton class must provide a global access point to get the instance of the class. Singleton pattern is used for logging, drivers objects, caching and thread pool. 

Used in Java : Singleton design pattern is used in core java classes also, for example java.lang.Runtime, java.awt.Desktop.

To implement Singleton pattern : 

1. Private default constructor to restrict instantiation of the class from other classes.
2. Private static variable of the same class that is the only instance of the class.
3. Public static method that returns the instance of the class, this is the global access point for outer world to get the instance of the singleton class.

Lazy Initialization (in single threaded environment) : Lazy initialization method to implement Singleton pattern creates the instance in the global access method. Here is the sample code for creating Singleton class with this approach.
Example :
public class LazyInitializedSingleton {
 
    private static LazyInitializedSingleton instance;
     
    private LazyInitializedSingleton(){}
     
    public static LazyInitializedSingleton getInstance(){
        if(instance == null){
            instance = new LazyInitializedSingleton();
        }
        return instance;
    }
}

The above implementation works fine in case of single threaded environment but when it comes to multi-threaded systems, it can cause issues if multiple threads are inside method at the same time. It will destroy the singleton pattern and both threads will get the different instances of singleton class.

Thread Safe Singleton : -->
----------------------
The easier way to create a thread-safe singleton class is to make the global access method synchronized, so that only one thread can execute this method at a time. General implementation of this approach is like the below class.

public class ThreadSafeSingleton {
 
    private static ThreadSafeSingleton instance;
     
    private ThreadSafeSingleton(){}
     
    public static synchronized ThreadSafeSingleton getInstance(){
        if(instance == null){
            instance = new ThreadSafeSingleton();
        }
        return instance;
    }
}

Above implementation works fine and provides thread-safety but it reduces the performance because of cost associated with the synchronized method, although we need it only for the first few threads who might create the separate instances (Read: Java Synchronization). To avoid this extra overhead every time, double checked locking principle is used. In this approach, the synchronized block is used inside the if condition with an additional check to ensure that only one instance of singleton class is created.

Below code snippet provides the double checked locking implementation.

public static ThreadSafeSingleton getInstanceUsingDoubleLocking(){
    if(instance == null){
        synchronized (ThreadSafeSingleton.class) {
            if(instance == null){
                instance = new ThreadSafeSingleton();
            }
        }
    }
    return instance;
}

Using Reflection to destroy Singleton Pattern :-->
------------------------------------------------
Reflection can be used to destroy all the above singleton implementation approaches. Letís see this with an example class.

import java.lang.reflect.Constructor;
public class ReflectionSingletonTest {
 
    public static void main(String[] args) {
	
        EagerInitializedSingleton instanceOne = EagerInitializedSingleton.getInstance();
        EagerInitializedSingleton instanceTwo = null;
    
    try {
            Constructor[] constructors = EagerInitializedSingleton.class.getDeclaredConstructors();

            for (Constructor constructor : constructors) 
			{
                //Below code will destroy the singleton pattern
                constructor.setAccessible(true);
                instanceTwo = (EagerInitializedSingleton) constructor.newInstance();
                break;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(instanceOne.hashCode());
        System.out.println(instanceTwo.hashCode());
    }
}

When you run the above test class, you will notice that hashCode of both the instances are not same that destroys the singleton pattern.
Reflection is very powerful and used in a lot of frameworks like Spring and Hibernate.

How to prevent Singleton Pattern from Reflection, Serialization and Cloning? :-->
-----------------------------------------------------------------------------

1. Enum : enum is special type of java class and it can have methods and other variables.  To overcome issue raised by reflection, enums are used because java ensures internally that 
  ------  enum value is instantiated only once. Since java Enums are globally accessible, they can be used for singletons. Its only drawback is that it is not flexible i.e it does not allow lazy initialization.

		 As enums don’t have any constructor so it is not possible for Reflection to utilize it. Enums have their by-default constructor, we can’t invoke them by ourself. 
		 JVM handles the creation and invocation of enum constructors internally. As enums don’t give their constructor definition to the program, it is not possible for us to access
		  them by Reflection also. Hence, reflection can’t break singleton property in case of enums.	


Example : -> com.dp.singleton.SingletonEnum
public enum SingletonEnum {

	INSTANCE;
	
	public static SingletonEnum getInstance() {
		return INSTANCE;
	}
}
public static void main(String[] args){

System.out.println("SingletonEnum Instance : "+ SingletonEnum.getInstance());
System.out.println("hashCode1111 : "+ SingletonEnum.getInstance().hashCode());
System.out.println("hashCode222 : "+ SingletonEnum.getInstance().hashCode());
}

Output: --> 
SingletonEnum Instance : INSTANCE
hashCode1111 : 356573597
hashCode222 : 356573597


2. Serialization:- Serialization can also cause breakage of singleton property of singleton classes. Serialization is used to convert an object of byte stream and save in a file or send over a network. Suppose you serialize an object of a singleton class. Then if you de-serialize that object it will create a new instance and hence break the singleton pattern. 
------------------
Overcome serialization issue:- To overcome this issue, we have to implement method readResolve() method.

Example : -> com.dp.singleton.SingletonSerializable

3. Cloning: Cloning is a concept to create duplicate objects. Using clone we can create copy of object. Suppose, we ceate clone of a singleton object, then it wil create a copy that is there are two instances of a singleton class, hence the class is no more singleton. 
Example : -> com.dp.singleton.SingletonClone


2. Factory Design Pattern : -->
----------------------------
Factory design pattern is used when we have a super class with multiple sub-classes and based on input we need to return one of the sub-class. This pattern take out the responsibility of instantiation of a class from client program to the factory class.
http://www.journaldev.com/1392/factory-design-pattern-in-java

Example: com.designpattern.factory.*
Factory PC Config::RAM= 2 GB, HDD=500 GB, CPU=2.4 GHz
Factory Server Config::RAM= 16 GB, HDD=1 TB, CPU=2.9 GHz

-------------------------------------

Benefits of Factory Pattern:-->
---------------------------
1. Factory pattern provides approach to code for interface rather than implementation.
2. Factory pattern removes the instantiation of actual implementation classes from client code, making it more robust, less coupled and easy to extend. For example, we can easily change PC class implementation because client program is unaware of this.
3. Factory pattern provides abstraction between implementation and client classes through inheritance.

Factory Pattern Examples in JDK

1. java.util.Calendar, ResourceBundle and NumberFormat getInstance() methods uses Factory pattern.
2. valueOf() method in wrapper classes like Boolean, Integer etc.

-----------------------------------

3. Abstract Factory Design Pattern :--> Abstract Factory pattern is “factory of factories” and can be easily extended to accommodate more products, for example we can add another sub-class Laptop and a factory LaptopFactory.
--------------------------------
1. Abstract Factory design pattern provides approach to code for interface rather than implementation.
2. Abstract Factory pattern is robust and avoid conditional logic of Factory pattern.
3. Abstract Factory pattern is “factory of factories” and can be easily extended to accommodate more products, for example we can add another sub-class Laptop and a factory LaptopFactory.
   Factory pattern Interface will return the objects of Factory classes ; Like : Computer, Laptop 
   

4. Facade Pattern in Java :-->
----------------------------
http://www.journaldev.com/1557/facade-pattern-in-java-example-tutorial
Facade Pattern is one of the Structural design patterns (such as Adapter pattern and Decorator pattern) and used to help client applications to easily interact with the system.
Facade pattern should be applied for similar kind of interfaces, its purpose is to provide a single interface rather than multiple interfaces that does the similar kind of jobs.
   
Suppose we have an application with set of interfaces to use MySql/Oracle database and to generate different types of reports, such as HTML report, PDF report etc. So we will have different set of interfaces to work with different types of database. 
Now a client application can use these interfaces to get the required database connection and generate reports. But when the complexity increases or the interface behaviour names are confusing, client application will find it difficult to manage it. So we can apply Facade pattern here and provide a wrapper interface on top of the existing interface to help client application.

Example : com.designpattern.facade.*

Important Points :
1. Facade pattern is more like a helper for client applications, it doesnít hide subsystem interfaces from the client. Whether to use Facade or not is  
   completely dependent on client code.
2. Facade pattern can be applied at any point of development, usually when the number of interfaces grow and system gets complex.
3. Subsystem interfaces are not aware of Facade and they shouldnít have any reference of the Facade interface.
4. Facade pattern should be applied for similar kind of interfaces, its purpose is to provide a single interface rather than multiple interfaces that does the similar kind of jobs.
5. We can use Factory pattern with Facade to provide better interface to client systems.


5. Adapter Pattern :-->
-----------------------
http://www.journaldev.com/1487/adapter-design-pattern-in-java-example-tutorial
Example: com.designpattern.adapter1
Adapter pattern works as a bridge between two incompatible interfaces, as this pattern combines the capability of two independent interfaces.
[ This type of design pattern comes under structural pattern as this pattern combines the capability of two independent interfaces.]
This pattern involves a single class which is responsible to join functionalities of independent or incompatible interfaces. 

We are demonstrating use of Adapter pattern via following example in which an audio player device can play mp3 files only and wants to use an advanced audio player capable of playing vlc and mp4 files

Example Implementation :-->
We have a  MediaPlayer  interface and a concrete class  AudioPlayer  implementing theMediaPlayer interface. AudioPlayer can play mp3 format audio files by default.
We are having another interface  AdvancedMediaPlayer and concrete classes implementing the AdvancedMediaPlayer interface. These classes can play vlc and mp4 format files.

---------------------------------------

Strategy Design Pattern:-->
------------------------
http://www.journaldev.com/1754/strategy-design-pattern-in-java-example-tutorial

[Strategy pattern is one of the behavioral design pattern].

Strategy pattern is used when we have multiple algorithm for a specific task and client decides the actual implementation to be used at runtime.
Here,We defines multiple algorithms and let client application pass the algorithm to be used as a parameter. One of the best example of this pattern is Collections.sort() method that takes Comparator parameter. 
Based on the different implementations of Comparator interfaces, the Objects are getting sorted in different ways.

Example:  We will try to implement a simple Shopping Cart where we have two payment strategies ñ using Credit Card or using PayPal.

Example : com.dp.strategy.PaymentStrategy

Important Points:
----------------
1. Strategy pattern is useful when we have multiple algorithms for specific task and we want our application to be flexible to chose any of the algorithm at runtime for specific task.
 
-------------------------------------------------------------
 
State Design Pattern :-->
----------------------
http://www.journaldev.com/1751/state-design-pattern-in-java-example-tutorial

State pattern is one of the behavioral design pattern. 

State design pattern is used when an Object change its behavior based on its internal state.

If we have to change the behavior of an object based on its state, we can have a state variable in the Object and use if-else condition block to perform different actions based on the state. Example : com.dp.state.TVRemoteBasic;

But State pattern is used to provide a systematic and lose-coupled way to achieve this through Context and State implementations.
Context is the class that has a State reference to one of the concrete implementations of the State and forwards the request to the state object for processing.

State Pattern is very similar to Strategy Pattern. One of the difference is that Context contains state as instance variable and there can be multiple tasks whose implementation can be dependent on the state whereas in strategy pattern, strategy is passed as argument to the method and context object doesnít have any variable to store it.

Important Points:
----------------
The benefits of using State pattern to implement polymorphic behavior is clearly visible, the chances of error are less and its very easy to add more states for additional behavior making it more robust, easily maintainable and flexible. Also State pattern helped in avoiding if-else or switch-case conditional logic in this scenario.

Example : com.dp.state.TVRemote

-------------------------------------------------

Flyweight Design Pattern : -->
-------------------------
Flyweight is used when there is a need to create high number of objects of almost similar nature. High number of objects consumes high memory and flyweight design pattern gives a solution to reduce the load on memory by sharing objects. It is achieved by segregating object properties into two types intrinsic and extrinsic. 

When to Use Flyweight DP :-->
-------------------------
*  Need to create large number of objects.
*  Because of the large number when memory cost is a constraint.
*  When most of the object attributes can be made external and shared.
*  The application must not mandate unique objects, as after implementation same object will be used repeatedly.
*  Its better when extrinsic state can be computed rather than stored.

How to Apply Flyweight :-->
------------------------
The object which we are going to create in high number should be analyzed before going for flyweight. Idea is to create lesser number of objects by reusing the same objects. Create smaller groups of objects and they should be reused by sharing. 
Consider a simple text editor where we can use only alphabet set A to Z. If we are going to create 100 page document using this editor we may have 200000 (2000 X 100) characters (assuming 2000 characters / page). Without flyweight we will create 200000 objects to have fine grained control. With such fine control, every character can have its own characteristics like color, font, size, etc. How do we apply flyweight here?

Flyweight Implementation :-->
---------------------------
When we implement flyweight we create concrete objects and have the intrinsic state stored in that , those object will be created using Flyweight factory. This factory is to ensure that the objects are shared and we don’t end up creating duplicate objects.

Example : com.dp.flyweight.*

--------------------------------------------------------------------
Template Method Design Pattern :-->
-------------------------------
http://www.journaldev.com/1763/template-method-design-pattern-in-java

Purpose of Template Design pattern is to execute set of methods in some sequence, As order changes may result in wrong outcome.
Letís understand this pattern with an example, suppose we want to provide an algorithm to build a house. The steps need to be performed to build a house are ñ building foundation, building pillars, building walls and windows. The important point is that the we canít change the order of execution because we canít build windows before building the foundation. So in this case we can create a template method that will use different methods to build the house.

Now building the foundation for a house is same for all type of houses, whether its a wooden house or a glass house. So we can provide base implementation for this, if subclasses want to override this method, they can but mostly itís common for all the types of houses.

To make sure that subclasses donít override the template method, we should make it final.

Example : com.designpattern.templatemethod.*

Important Points :-->

1. Template method should consists of certain steps whose order is fixed and for some of the methods, implementation differs from base class to subclass. Template method should be final.
2. Most of the times, subclasses calls methods from super class but in template pattern, superclass template method calls methods from subclasses, this is known as Hollywood Principle ñ ìdonít call us, weíll call you.î.
3. Methods in base class with default implementation are referred as Hooks and they are intended to be overridden by subclasses, if you want some of the methods to be not overridden, you can make them final, for example in our case we can make buildFoundation() method final because if we donít want subclasses to override it.

---------------------------------------------------------------------------------------------------------

												Design Principles
											--------------------------
												

# Design Principles : 5 Class Design Principles [S.O.L.I.D.] in Java:
----------------------------------------------------------------------
1. Single Responsibility Principle: "One class should have one and only one responsibility".
									 In other words, you should write, change and maintain a class for only one purpose. If it is model class then it should strictly represent only one actor/ entity. This will give you the flexibility to make changes in future without worrying the impacts of changes for another entity.
Similarly, If you are writing service/manager class then it should contain only that part of method calls and nothing else. Not even utility global functions related to module. Better separate them in another globally accessible class file. This will help in maintaining the class for that particular purpose, and you can decide the visibility of class to specific module only.

2. Open Closed Principle : "Software components should be open for extension, but closed for modification".
							The Open/Closed Principle states that code entities should be open for extension, but closed for modification. To put this more concretely, you should write a class that does what it needs to flawlessly and not assuming that people should come in and change it later. It's closed for modification, but it can be extended by, for instance, inheriting from it and overriding or extending certain behaviors. 
A great example of this in real life is sitting in your pocket in the form of a smartphone. All such phones have app stores and these app stores let you extend the base functionality of the phone. Sure, it ships with the basics: camera operation, actual calls, text messages, etc. But via the app store, you can extend the phone's capabilities to allow you to manage your todo list, play inane video games, and even serve as a flashlight or wireless access point.

3. Liskov’s Substitution Principle : "Derived types must be completely substitutable for their base types"
									  It means that the classes fellow developer created by extending your class should be able to fit in application without failure. I.e. if a fellow developer poorly extended some part of your class and injected into framework/ application then it should not break the application or should not throw fatal exceptions.
This can be insured by using strictly following first rule. If your base class is doing one thing strictly, the fellow developer will override only one feature incorrectly in worst case. This can cause some errors in one area, but whole application will not do down.
	
4. Interface Segregation Principle : "Clients should not be forced to implement unnecessary methods which they will not use"
									Take an example. Developer Alex created an interface Reportable and added two methods generateExcel() and generatedPdf(). Now client ‘A’ wants to use this interface but he intend to use reports only in PDF format and not in excel. Will he achieve the functionality easily.
NO. He will have to implement two methods, out of which one is extra burden put on him by designer of software. Either he will implement another method or leave it blank. So are not desired cases, right??
So what is the solution? Solution is to create two interfaces by breaking the existing one. They should be like PdfReportable and ExcelReportable. This will give the flexibility to user to use only required functionality only.

5. Dependency Inversion Principle : "Depend on abstractions, not on concretions".
									In other words. you should design your software in such a way that various modules can be separated from each other using an abstract layer to bind them together. 
You can recognize this in the code you read by looking for a class or method that takes something generic like "Stream" and performs operations on it, as opposed to instantiating a specific Filestream or Stringstream or whatever. This gives the code in question a lot more flexibility -- you can swap in anything that conforms to the Stream abstraction and it will still work.

-------------------------------------------

# Happens Before :
-------------------
https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html
	

--------------------------------------------------------------------------------------------	
	
		Topic						:: IO (Input/Output) :: File Handeling ::
					
					
Serializable in Java : Serializable is the process, with that a Object can be wriiten into a file, it can be read from the file called deserialization or 
--------------------- can be sent it over the network.
If you want a class object to be serializable, all we need to do it implement the java.io.Serializable interface. Serializable in java is a marker interface and has no fields or methods to implement. 
Serialization in java is implemented by ObjectInputStream and ObjectOutputStream, so all we need is a wrapper over them to either save it to file or send it over the network.
//OR
Serialization is a mechanism of converting the state of an object into a byte stream. Deserialization is the reverse process where the byte stream is used to recreate the actual Java object in memory.


Example : com.qna.serialization.Employee ,SerializationUtil, SerializationTest
Outout ==> emp Object::Employee{name=Pankaj,id=100,salary=5000}
empNew Object::Employee{name=Pankaj,id=100,salary=0}
					
* If you want an object property to be not serialized to stream, you can use transient keyword like I have done with password variable.					
		
* Since password is a transient variable, itís value was not saved to file and hence not retrieved in the new object. Similarly static variable values are also not serialized since they belongs to class and not object.

Class Refactoring with Serialization and serialVersionUID :
---------------------------------------------------------
Serialization in java permits some changes in the java class if they can be ignored. Some of the changes in class that will not affect the deserialization process are:

    Adding new variables to the class
    Changing the variables from transient to non-transient, for serialization itís like having a new field.
    Changing the variable from static to non-static, for serialization itís like having a new field.

But for all these changes to work, the java class should have serialVersionUID defined for the class.

Now uncomment the ìpasswordî variable and itís getter-setter methods from Employee class and run it. You will get below exception;
java.io.InvalidClassException: com.journaldev.serialization.Employee; local class incompatible: stream classdesc serialVersionUID = -6470090944414208496, local class serialVersionUID = -6234198221249432383
	at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:604)
	
The reason is clear that serialVersionUID of the previous class and new class are different. Actually if the class doesnít define serialVersionUID, 
itís getting calculated automatically and assigned to the class. Java uses class variables, methods, class name, package etc to generate this unique long number.
If you are working with any IDE, you will automatically get a warning that ìThe serializable class Employee does not declare a static final serialVersionUID field of type longî.

For example, uncomment only the serialVersionUID field from the Employee class and run DeserializationTest program and you will see that the object stream is deserialized successfully because the change in Employee class is compatible with serialization process.

Example : com.qna.serialization.DeserializationTest

What’s wrong with the default serialVersionUID? : 
------------------------------------------------
If no serialVersionUID is declared, JVM will use its own algorithm to generate a default SerialVersionUID.
The default serialVersionUID computation is highly sensitive to class details and may vary from different JVM implementation, and result in an unexpected InvalidClassExceptions during the deserialization process. 

Examples :1. Client / Server environment :==> 
– Client is using SUN’s JVM in Windows.
– Server is using JRockit in Linux. 
The client sends a serializable class with default generated serialVersionUID (e.g 123L) to the server over socket, the server may generate a different serialVersionUID (e.g 124L) during deserialization process, and raises an unexpected InvalidClassExceptions.

2. File / Database environment ==>
– App #1 is using SUN’s JVM in Windows.
– App #2 is using JRockit in Linux.

Serialization has allowed to save into a file or database. App #1 stores a serializable class into database by default generated serialVersionUID (e.g 123L), while App #2 may generate a different serialVersionUID (e.g 124L) during deserialization process, and raise an unexpected InvalidClassExceptions.

How to generate serialVersionUID :   There are three ways to generate serialVersionUID for your serialization class.
---------------------------------
1. serialver command : ==> JDK has a build in command called “serialver” to generate the serialVersionUID automatically. In this example, you use “serialver” to generate a serialVersionUID for Address class.
    Example :==>  E:\workspace\target\classes>serialver Address
				  Address:    static final long serialVersionUID = -687991492884005033L;

2. Use Eclispe IDE : ==> If you are using Eclipse, move your mouse over the serialization class. Or Click on the serialization class and press “CTRL + 1“.

3. Anything you want :==>  Just specify your own serialVersionUID , give a number and append an “L” behind.
    Example :==> private static final long serialVersionUID = 1L;

Serialization and Externalization:
-------------------------------------
Both serializable and extenalizable used to serialize or persist java objects but the way they do is little different. In case of Serializable Java Virtual machine 
has full control for serializing object while in case of Externalizable, application gets control for persisting objects. writeExternal() and readExternal() method provides 
complete control on format and content of Serialization process to application which can be leverage to increase performance and speed of serialization process.
Example :com.oops.externalizable.ExternalizationTest


Serialization with respect to inheritance: There are some cases of Serialization with respect to inheritance :
------------------------------------------
https://www.geeksforgeeks.org/object-serialization-inheritance-java/

Case 1: If superclass is serializable then subclass is automatically serializable  :
-----------------------------------------------------------------------------------
Serializable, then by default every subclass is serializable. Hence, even though subclass doesn’t implement Serializable interface( and if it’s superclass implements Serializable), then we can serialize subclass object. 
Example : com.oops.serialization.inheritance.SerializationInheritance

Case 2 : What happens when a sub-class is serializabled but its superclass is not ?  :
----------------------------------------------------------------------------
Serialization: At the time of serialization, if any instance variable is inheriting from non-serializable superclass, then JVM ignores original value of that instance variable and save default value to the file.
De-Serialization: At the time of de-serialization, if any non-serializable superclass is present, then JVM will execute instance control flow in the superclass. To execute instance control flow in a class, JVM will always invoke default(no-arg) constructor of that class. So every non-serializable superclass must necessarily contain default constructor, otherwise we will get runtime-exception.
Note : In this case while Serialization JVM will save variable`s default value (since its int i so i`s values will be value 0.) and while De-Serialization it will call the default constructor of super class and will update the variable accordingly (so here i value becomes 50 from 0).

Case 3 : If the superclass is serializable but we don’t want the subclass to be serialized : 
----------------------------------------------------------------------------
There is no direct way to prevent subclass from serialization in java. One possible way by which a programmer can achieve this is by implementing the writeObject() and readObject() methods in the subclass and needs to throw NotSerializableException from these methods.
These methods are executed during serialization and de-serialization respectively. By overriding these methods, we are just implementing our own custom serialization. 


Transient Variable :If any variable declared as transient then it will not be serialized.Default value of variable will be as per primitive type or null if its any Object.
------------------	
Example : -->
transient int i =10;
int j =20;
           here, 0 and 20 will be saved in file (i is of int type so its default value is 0) 


Transient vs static:--> since static variables are class level and does`t belong to object state so it will not be serialized so when we de-serialize an object 
---------------------- then system reads the static variable`s value from method area. So no use making static variable as transient. (but if you make it than there will not be any error).
Example :--> transient static int i =10;

Transient vs final :--> since final variable`s will never change and variables converts in original value at compile time. so 
--------------------    direct value will be serialized. like, final int i =10; then original value (10) will be serialized 	
						not i=10;
so no use of making final variable as transient. (but if you make it than there will not be any error).

Example :--> Transient final int i =10;

------------------------------------------------------------------

			
OutputStream:
--------------
Java application uses an output stream to write data to a destination, it may be a file,an array,peripheral device or socket.
OutputStream class is an abstract class.It is the superclass of all classes representing an output stream of bytes. An output stream accepts output bytes and sends them to some sink. 

Method	Description:
1) public void write(int)throws IOException:	is used to write a byte to the current output stream.
2) public void write(byte[])throws IOException:	is used to write an array of byte to the current output stream.
3) public void flush()throws IOException:	flushes the current output stream.
4) public void close()throws IOException:	is used to close the current output stream.
See Hierarchy
D:\STUDY\DATA\Interview\Java Granth\io\OutputStream.jpg

Example : BasicOfJava\Basics\com.basics.io.FileOutputStreamTest

InputStream:
------------
Java application uses an input stream to read data from a source, it may be a file,an array,peripheral device or socket.

Method	Description :
1) public abstract int read()throws IOException:	reads the next byte of data from the input stream.It returns -1 at the end of file.
2) public int available()throws IOException:	returns an estimate of the number of bytes that can be read from the current input stream.
3) public void close()throws IOException:	is used to close the current input stream.

See Hierarchy
D:\STUDY\DATA\Interview\Java Granth\io\InputStream.jpg

Example of Reading the data of current java file and writing it into another file:
Example : BasicOfJava\Basics\com.basics.io.ReadWriteTest
					

ByteArrayOutputStream class :
----------------------------
Java ByteArrayOutputStream class is used to write data into multiple files. In this stream, the data is written into a byte array that can be written to multiple stream.
The ByteArrayOutputStream holds a copy of data and forwards it to multiple streams.
The buffer of ByteArrayOutputStream automatically grows according to data. 

Constructor	Description:
ByteArrayOutputStream() :	creates a new byte array output stream with the initial capacity of 32 bytes, though its size increases if necessary.
ByteArrayOutputStream(int size) : creates a new byte array output stream, with a buffer capacity of the specified size, in bytes.

Method	Description :
1) public synchronized void writeTo(OutputStream out) throws IOException : writes the complete contents of this byte array output stream to the specified output stream.
2) public void write(byte b) throws IOException :	writes byte into this stream.
3) public void write(byte[] b) throws IOException : writes byte array into this stream.
4) public void flush()	: flushes this stream.
5) public void close()	: has no affect, it doesn't closes the bytearrayoutputstream.					


BufferedOutputStream :
---------------------
Java BufferedOutputStream class uses an internal buffer to store data. It adds more efficiency than to write data directly into a stream. So, it makes the performance fast.
In this example, we are writing the textual information in the BufferedOutputStream object which is connected to the FileOutputStream object. The flush() flushes the data of one stream and send it into another. It is required if you have connected the one stream with another. 

Example : BasicOfJava\Basics\com.basics.io.BufferedOutputStreamTest

BufferedInputStream:
-------------------
Java BufferedInputStream class is used to read information from stream. It internally uses buffer mechanism to make the performance fast.
Example : BasicOfJava\Basics\com.basics.io.BufferedInputStreamTest

-----------------------------------------------------------------------------
							
							
											File Handeling
											----------------

How to create a new File in Java:
--------------------------------
java.io.File class can be used to create a new File in Java. When we initialize File object, we provide the file name and then we can call createNewFile() method to create a new file in Java. This method returns boolean true if new file is created and false if file already exists. This method also throws java.io.IOException when itís not able to create the file. The files created is empty and of zero bytes.

When we create the File object by passing file name, it can be with absolute path, or we can only provide the file name or we can provide relative path. For non-absolute path, File object tries to locate files in the project root directory. If we run the program from command line, for non-absolute path, File object tries to locate files from the current directory as base.

While creating the file path, we should use System property ìfile.separatorî to make our program platform independent. it creates backword sless "\".					

Example : BasicOfJava\Basics\com.basics.io.CreateNewFile


How to delete a File or empty directory/folder in Java:
------------------------------------------------------
java.io.File delete() method can be used to delete files or empty directory/folder in java. It returns true if file gets deleted and returns false if if file doesnít exist. If you are trying to delete a directory, it checks if itís empty or not. If directory is empty, it gets deleted else delete() method doesnít do anything and return false.

 Example : BasicOfJava\Basics\com.basics.io.DeleteFileJava


FileWriter and FileReader (File Handling in java):
-------------------------------------------------
Java FileWriter and FileReader classes are used to write and read data from text files. These are character-oriented classes, used for file handling in java.
Java has suggested not to use the FileInputStream and FileOutputStream classes if you have to read and write the textual information.

Constructor	Description:
FileWriter(String file) : creates a new file. It gets file name in string.
FileWriter(File file)	: creates a new file. It gets file name in File object.

Method	Description:
1) public void write(String text) :	writes the string into FileWriter.
2) public void write(char c) :	writes the char into FileWriter.
3) public void write(char[] c) : writes char array into FileWriter.
4) public void flush()	: flushes the data of FileWriter.
5) public void close()	: closes FileWriter. 

Example : BasicOfJava\Basics\com.basics.io.FileWriterTest 

FileReader :
-----------
Java FileReader class is used to read data from the file. It returns data in byte format like FileInputStream class.

Constructor	Description:
FileReader(String file)	: It gets filename in string. It opens the given file in read mode. If file doesn't exist, it throws FileNotFoundException.
FileReader(File file)	: It gets filename in file instance. It opens the given file in read mode. If file doesn't exist, it throws FileNotFoundException.

Method	Description:
1) public int read() : returns a character in ASCII form. It returns -1 at the end of file.
2) public void close()	: closes FileReader.

Example : BasicOfJava\Basics\com.basics.io.FileReaderTest

CharArrayWriter class:
---------------------
The CharArrayWriter class can be used to write data to multiple files. This class implements the Appendable interface. Its buffer automatically grows when data is written in this stream. Calling the close() method on this object has no effect.  

Example : BasicOfJava\Basics\com.basics.io.CharArrayWriterTest 
 
 
Java File separator, separatorChar, pathSeparator, pathSeparatorChar:
---------------------------------------------------------------------
java.io.File class contains four static separator variables. Here we will learn about them and when to use it.

 1. separator: Platform dependent default name-separator character as String. For windows, itís ë\í and for unix itís ë/í.
 2. separatorChar: Same as separator but itís char.
 3. pathSeparator: Platform dependent variable for path-separator. For example PATH or CLASSPATH variable list of paths separated by ë:í in Unix systems and ë;í in Windows system.
 4. pathSeparatorChar: Same as pathSeparator but itís char.

Note that all of these are final variables and system dependent.

Example : BasicOfJava\Basics\com.basics.io.FileSeparator

Windows Output:
File.separator = \
File.separatorChar = \
File.pathSeparator = ;
File.pathSeparatorChar = ;
 
Unix Outout:
File.separator = /
File.separatorChar = /
File.pathSeparator = :
File.pathSeparatorChar = :


How to get File size in Java:
----------------------------
java.io.File length() can be used to get the file size, this method returns the file size in bytes.
While using length() function, you should always check if file exists or not, if file doesnít exist, this method returns zero. 
 
Example : BasicOfJava\Basics\com.basics.io.FileSize
 

How to check File is Directory or File in java:
----------------------------------------------
java.io.File class contains two methods using which we can find out if the file is a directory or a regular file in java.

    isFile(): This method returns true if file exists and is a regular file, note that if file doesnít exist then it returns false.
    isDirectory(): This method returns true if file is actually a directory, if path doesnít exist then it returns false.

While checking if a file is directory or regular file, we should first check if file exists or not. If it exists then only we should check if itís a directory or file.

Example : BasicOfJava\Basics\com.basics.io.CheckDirectoryOrFile


How to check if File exists in Java:
------------------------------------
java.io.File class exists() method can be used to check if file exists or not in java. If file exists, it returns true else this method returns false.

Example : BasicOfJava\Basics\com.basics.io.FileExists
 
How to read Object from File in Java:
------------------------------------
java.io.BufferedReader: BufferedReader is good if you want to read file line by line and process on them. Itís good for processing large file and it supports encoding also. BufferedReader is synchronized, so read operations on a BufferedReader can safely be done from multiple threads. BufferedReader default buffer size is 8KB.

java.io.FileReader: You can use FileReader to get the BufferedReader and then read files line by line. FileReader doesnít support encoding and works with the system default encoding, so itís not very efficient way of reading file in java.


-----------------------------------------------------------------------------------------------------------

Topic 								:: Exception  ::

http://www.journaldev.com/2167/java-exception-interview-questions-and-answers
Exception : Exception is an error event that can happen during the execution of a program and disrupts itís normal flow. Exception can arise from different kind of situations such as wrong data entered by user, hardware failure, network connection failure etc.
Whenever any error occurs while executing a java statement, an exception object is created and then JRE tries to find exception handler to handle the exception. If suitable exception handler is found then the exception object is passed to the handler code to process the exception, known as catching the exception. If no handler is found then application throws the exception to runtime environment and JRE terminates the program. 

Quest : What are the Exception Handling Keywords in Java?
Ans :  
throw ñ We know that if any exception occurs, an exception object is getting created and then Java runtime starts processing to handle them. Sometime we might want to generate exception explicitly in our code, for example in a user authentication program we should throw exception to client if the password is null. throw keyword is used to throw exception to the runtime to handle it.
throws ñ When we are throwing any Checked Exception in a method and not handling it, then we need to use throws keyword in method signature to let caller program know the exceptions that might be thrown by the method. The caller method might handle these exceptions or propagate it to itís caller method using throws keyword. We can provide multiple exceptions in the throws clause and it can be used with main() method also. unchecked Exception can also be declared using Throws but not necessary. 

try-catch ñ We use try-catch block for exception handling in our code. try is the start of the block and catch is at the end of try block to handle the exceptions. We can have multiple catch blocks with a try and try-catch block can be nested also. catch block requires a parameter that should be of type Exception.

finally ñ finally block is optional and can be used only with try-catch block. Since exception halts the process of execution, we might have some resources open that will not get closed, so we can use finally block. finally block gets executed always, whether exception occurred or not.


How to do exception handling for overriding and overridden methods :-->
--------------------------------------------------------------------
Rule:-->  An overriding method (the method of child class) can throw any unchecked exceptions, regardless of whether the overridden method (method of base class) throws any exceptions or not. However the overriding method should not throw checked exceptions that are new or broader than the ones declared by the overridden method. The overriding method can throw those checked exceptions, which have less scope than the exception(s) declared in the overridden method.

Letís understand the above explanation with the help of few examples:-->

Example 1: If base class doesnít throw any exception but child class throws an unchecked exception.

class Building {  
   void color()
   {
       System.out.println("Blue");
   }  
}
class Room extends Building{
   //It throws an unchecked exception
   void color() throws NullPointerException
   {
       System.out.println("White");
   }  
   public static void main(String args[]){  
       Building obj = new Room();  
       obj.color(); 
   } 
}

Output : --> White

Example 2: If base class doesnít throw any exception but child class throws an checked exception
import java.io.*;
class Building {  
   void color()
   {
      System.out.println("Blue");
   }  
}
class Room extends Building{
   void color() throws IOException
   {
      System.out.println("White");
   }  
   public static void main(String args[]){  
      Building obj = new Room();  
      try{
         obj.color();
      }catch(Exception e){
         System.out.println(e);
       }
   } 
}

Output : --> The above code is having a compilation error: Because the overriding method (child class method) cannot throw a checked exception if the overridden method(method of base class) is not throwing an exception.

Example 3: When base class and child class both throws a checked exception.
import java.io.*;
class Building {  
   void color() throws IOException
   {
       System.out.println("Blue");
   }  
}
class Room extends Building{
    void color() throws IOException
    {
        System.out.println("White");
    }  
    public static void main(String args[]){  
        Building obj = new Room();  
        try{
	   obj.color();
	}catch(Exception e){
	   System.out.println(e);
	 }
    } 
}

Output:--> White
Note : The code ran fine because color() method of child class is NOT throwing a checked exception with scope broader than the exception declared by color() method of base class or any new checked Exception.

Example 4: When child class method is throwing border checked exception compared to the same method of base class.
import java.io.*;
class Building {  
	void color() throws IOException
	{
		  System.out.println("Blue");
	}  
}
class Room extends Building{
	  void color() throws Exception
	  {
		  System.out.println("White");
	  }  
	  public static void main(String args[]){  
		   Building obj = new Room();  
		   try{
		   obj.color();
		   }catch(Exception e){
			   System.out.println(e);
		   }
	  } 
}

Output:-->
Compilation error because the color() method of child class is throwing Exception which has a broader scope than the exception thrown by method color() of parent class.

Important Points about Exception Handling:-->
---------------------------------------------
1. We canít have catch or finally clause without a try statement.
2. A try statement should have either catch block or finally block, it can have both blocks.
3. We canít write any code between try-catch-finally block.
4. We can have multiple catch blocks with a single try statement.
5. try-catch blocks can be nested similar to if-else statements.
6. We can have only one finally block with a try-catch statement.

--------------------------------------------------------------------------------------------

							Java (JVM)  Memory Management (Stack and Heap)
							------------------------------------------------
		
		
Memory Division : The heap is divided into three sections: Young/New Generation , Old Generation,Permanent Generation.
----------------

Young Generation : Heap memory creates new objects in the portion called as young generation. This portion is dedicated for storing the young objects which are very newly created by the Java applications.
-----------------		
		
Old Generation: This is another logical portion inside heap memory for storing the older objects. When new objects are created, that are reside inside young generation portion for certain period of time, after that those objects will be pushed to the old generation portion. Objects which are survived from garbage collector for few times will be promoted to the old generation.
---------------

Permanent Generation: Metadata such as classes and methods are stored in the Permanent Generation. Classes that are no longer in use may be garbage collected from the Permanent Generation.
--------------------
		
Permanent Generation (Replaced by Metaspace since Java 8) :
---------------------------------------------------------
Permanent Generation or Perm Gen contains the application metadata required by the JVM to describe the classes and methods used in the application. Perm Gen is populated by JVM at runtime based on the classes used by the application. Perm Gen also contains Java SE library, classes and methods. Perm Gen objects are garbage collected in a full garbage collection.

Metaspace:
--------------
With Java 8, there is no Perm Gen, that means there is no more ìjava.lang.OutOfMemoryError: PermGenî space problems. Unlike Perm Gen which resides in the Java heap, Metaspace is not part of the heap. Most allocations of the class metadata are now allocated out of native memory. Metaspace by default auto increases its size (up to what the underlying OS provides), while Perm Gen always has fixed maximum size. 
Two new flags can be used to set the size of the metaspace, they are: -XX:MetaspaceSize and -XX:MaxMetaspaceSize.

	
What is PermGen ?
Short form for Permanent Generation, PermGen is the memory area in Heap that is used by the JVM to store class and method objects. If your application loads lots of classes, PermGen utilization will be high.
PermGen also holds interned Strings
The size of the PermGen space is configured by the Java command line option -XX:MaxPermSize
							
The JDK 8 HotSpot JVM is now using native memory for the representation of class metadata and is called Metaspace; 

PermGen space situation:
This memory space is completely removed.
The PermSize and MaxPermSize JVM arguments are ignored and a warning is issued if present at start-up.
Most allocations for the class metadata are now allocated out of native memory.

Metaspace capacity:
By default class metadata allocation is limited by the amount of available native memory (capacity will of course depend if you use a 32-bit JVM vs. 64-bit along with OS virtual memory availability).
A new flag is available (MaxMetaspaceSize), allowing you to limit the amount of native memory used for class metadata. If you donít specify this flag, the Metaspace will dynamically re-size depending of the application demand at runtime.
The maximum metaspace size can be set using the -XX:MaxMetaspaceSize flag, and the default is unlimited, which means that only your system memory is the limit. The -XX:MetaspaceSize tuning flag defines the initial size of metaspace If you donít specify this flag, the Metaspace will dynamically re-size depending on the application demand at runtime.

Metaspace garbage collection:
Garbage collection of the dead classes and classloaders is triggered once the class metadata usage reaches the MaxMetaspaceSize.
Proper monitoring & tuning of the Metaspace will obviously be required in order to limit the frequency or delay of such garbage collections. 

---------------------------------------------

										GC (Garbage Collection)
									----------------------------------	

Garbage Collector is a Daemon thread that keeps running in the background. Basically, it frees up the heap memory by destroying the unreachable objects.
Unreachable objects are the ones that are no longer referenced by any part of the program.We can choose the garbage collector for our java program through JVM options.

This behavior was used to improve the performance of JVM, and the adopted methodology is commonly called Generational Garbage Collection.
In this method, the Heap space is divided into generations like Young Generation, Old or Tenured Generation, and Permanent Generation.

# The Young generation heap space is the new where all the new Objects are created. Once it gets filled up, minor garbage collection (also known as, Minor GC) takes place. Which means, all the dead objects from this generation are destroyed This process is quick because as we can see from the graph, most of them would be dead. The surviving objects in young generation are aged and eventually moves to the older generations. 
# The Old Generation is used to store long surviving objects. Typically, a threshold is set for young generation object and when that age is met, the object gets moved to the old generation. Eventually, the old generation needs to be collected. This event is called a Major GC (major garbage collection). Often it is much slower because it involves all live objects.
# Also, there is Full GC, which means cleaning the entire Heap – both Young and older generation spaces.

Lastly, up to Java 7, there was a Permanent Generation (or Perm Gen), which contained metadata required by the JVM to describe the classes and methods used in the application. It was removed in Java 8.

Default garbage collectors:
    Java 7 - Parallel GC
    Java 8 - Parallel GC
    Java 9 - G1 GC

Garbage Collectors : 4 types of 4 Java Garbage Collectors
-------------------
1. Serial GC : This is the simplest garbage collector, designed for single threaded systems and small heap size. It freezes all applications while working. 
               Can be turned on using -XX:+UseSerialGC JVM option.

2. Parallel/Throughput GC : As the name suggests, it uses multiple threads to scan through the heap space and perform compaction. A drawback of this collector is that it pauses the application threads while performing minor or full GC.
							It is best suited if applications that can handle such pauses, and try to optimize CPU overhead caused by the collector.
Can be turned on using -XX:+UseParallelOldGC JVM option.

3. The CMS collector (“concurrent-mark-sweep”) Algorithm : This algorithm uses multiple Concurrent threads to scan the heap memory to mark instances for eviction/removal and then sweep the marked instances.
														  Major garbage collection is multi-threaded, like Parallel Old, but CMS runs concurrently alongside application processes to minimize “stop the world” events (i.e. when the garbage collector running stops the application). No compaction is performed.		   
Can be turned on using -XX:+UseConcMarkSweepGC and to set the number of threads use: -XX:ParallelCMSThreads=<n>														   													   
Example : java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseConcMarkSweepGC -XX:ParallelCMSThreads=2 -jar c:\javademos\demo\jfc\Java2D\Java2demo.jar														   
														   	
4. G1 collector : The Garbage first collector (G1) introduced in JDK 7 update 4 was designed to better support heaps larger than 4GB. The G1 collector utilizes multiple background threads to mark the liveliness/unreferenced objects throughout the heap. After the marking phase is complete, G1 knows which regions are mostly empty. It collects unreachable objects from these regions first, which usually yields a large amount of free space. So G1 collects these regions(containing garbage) first, and hence the name Garbage-First.
				  This strategy reduced the chances of the heap being depleted before the background threads have finished scanning for unreachable objects. Also, it compacts the heap on-the-go, which the CMS collector can do only in STW (Stop-The-World) mode.
G1 can be enabled using the –XX:+UseG1GC flag.

Note : G1 is the default garbage collector in JDK 9.

G1 collector with String deduplication : In Java 8 a beautiful optimization is provided with G1 collector, called string deduplication. As we know the character arrays that represent our strings occupies much of our heap space. A new optimization has been made that enables the G1 collector to identify strings which are duplicated more than once across our heap and modify them to point to the same internal char[] array, to avoid multiple copies of the same string residing in the heap unnecessarily.
                                         We can use the -XX:+UseStringDeduplication JVM argument to enable this optimization.


GC Optimization Options:

Option 						Description
-Xms 				Sets the initial heap size for when the JVM starts.
-Xmx 				Sets the maximum heap size.
-Xmn 				Sets the size of the Young Generation.
-XX:PermSize 		Initial Permanent Generation size
-XX:MaxPermSize 	Maximum Permanent Generation size

Note : The consequences of the PermGen removal is that obviously the PermSize and MaxPermSize JVM arguments are ignored and you will never get a java.lang.OutOfMemoryError: PermGen error.

-XX:MetaspaceSize    Initial size of metaspace [If you don’t specify this flag, the Metaspace will dynamically re-size depending of the application demand at runtime].
-XX:MaxMetaspaceSize  Java Maximum Metaspace space [the default is unlimited, which means that only your system memory is the limit.]


Example Usage of JVM GC Options : java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar java-application.jar
					

Just-In-Time (JIT) :-->  The Just-In-Time (JIT) compiler is a component of the JRE (Java Runtime Environment) that improves the performance of Java applications at run time. It helps improve the performance of Java programs by compiling bytecodes into native machine code at runtime .
----------------------
Java programs using a compiler (javac) for converting Java source code(.java files) to Java bytecode (.class files). Once this is done, Java Virtual Machine (JVM) loads the .class files at run time and converts them to a machine understandable code using an interpreter.
Just-In-Time (JIT) compiler is a feature of JVM which when enabled makes the JVM analyse the method calls in byte code and compiles them to more native and efficient code. At this point of time, Just-In-Time (JIT) optimizes the prioritized method calls.
Once these method calls are compiled, the JVM then executes this optimized code instead of interpreting it. Ideally the efficiency of running object code will overcome the inefficiency of recompiling the program every time it runs.
The bytecode is platform-independent code that can be sent to any platform and run on that platform.

-------------------------------------------------------------------------------------------------------------

http://www.journaldev.com/1696/java-exception-handling-tutorial-with-examples-and-best-practices#best-practices
http://www.journaldev.com/1696/java-exception-handling-tutorial-with-examples-and-best-practices

--------------------------------------------------------------------------------------
Topic 						::		Data Structure		::
	

http://www.everybrickmatters.com/2013/08/stack-program-impelementation.html



-----------------------------------------------------------------------------------------
Topic        							:: HR Questions ::


Quest 3: Tell me about yourself (if asked by technical Person) ?
Ans : Myself /test Paliwal, am having 4.9 years of experience in building enterprise application using Java/J2EE technologies.
Currently I am working with Manhattan associates as SSE. As per as my education concern After completing Bachelor of Engineering with Computer Science branch from RGTU Bhopal , I have done CDAC from ACTS Bangalore.
Currently I am working with Enterprise Order management project which uses Java,Spring